---
source: crates/pina_codama_renderer/src/lib.rs
expression: content
---
//! This code was AUTOGENERATED by `pina_codama_renderer`.
//! Please DO NOT EDIT THIS FILE directly.
//! Regenerate it from Codama IDLs instead.

use bytemuck::Pod;
use bytemuck::Zeroable;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Pod, Zeroable)]
pub struct CounterState {
/// On-chain counter state.
/// 
/// The `#[account]` macro generates:
/// - A discriminator field (`CounterAccountType::CounterState`) as the first
/// byte.
/// - `Pod` + `Zeroable` derives for zero-copy (de)serialization.
/// - `HasDiscriminator` linking this struct to
/// `CounterAccountType::CounterState`.
/// - `TypedBuilder` for ergonomic construction.
/// 
/// Layout (10 bytes total):
/// ```text
/// | offset | size | field         |
/// |--------|------|---------------|
/// | 0      | 1    | discriminator |
/// | 1      | 1    | bump          |
/// | 2      | 8    | count (PodU64)|
/// ```
	pub discriminator: u8,
	/// The PDA bump seed, stored on-chain so we don't need to re-derive it.
	pub bump: u8,
	/// The current counter value. Uses `PodU64` (a little-endian `u64`
	/// wrapper) for safe alignment in `#[repr(C)]` structs.
	pub count: pina_pod_primitives::PodU64,
}

pub const COUNTER_STATE_DISCRIMINATOR: u8 = 1u8;

impl CounterState {
	pub const LEN: usize = core::mem::size_of::<Self>();

	pub const fn new(bump: u8, count: pina_pod_primitives::PodU64) -> Self {
		Self {
			discriminator: COUNTER_STATE_DISCRIMINATOR,
			bump,
			count,
		}
	}

	pub fn from_bytes(data: &[u8]) -> Result<&Self, solana_program_error::ProgramError> {
		let account = bytemuck::try_from_bytes::<Self>(data)
			.map_err(|_| solana_program_error::ProgramError::InvalidAccountData)?;
		if account.discriminator != COUNTER_STATE_DISCRIMINATOR {
			return Err(solana_program_error::ProgramError::InvalidAccountData);
		}
		Ok(account)
	}

	pub fn from_bytes_mut(data: &mut [u8]) -> Result<&mut Self, solana_program_error::ProgramError> {
		let account = bytemuck::try_from_bytes_mut::<Self>(data)
			.map_err(|_| solana_program_error::ProgramError::InvalidAccountData)?;
		if account.discriminator != COUNTER_STATE_DISCRIMINATOR {
			return Err(solana_program_error::ProgramError::InvalidAccountData);
		}
		Ok(account)
	}
}

impl<'a> TryFrom<&solana_account_info::AccountInfo<'a>> for CounterState {
	type Error = solana_program_error::ProgramError;

	fn try_from(account_info: &solana_account_info::AccountInfo<'a>) -> Result<Self, Self::Error> {
		let data_ref = (*account_info.data).borrow();
		let account = Self::from_bytes(&data_ref)?;
		Ok(*account)
	}
}
