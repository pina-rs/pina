---
source: crates/pina_codama_renderer/src/lib.rs
expression: content
---
//! This code was AUTOGENERATED by `pina_codama_renderer`.
//! Please DO NOT EDIT THIS FILE directly.
//! Regenerate it from Codama IDLs instead.

pub const TAKE_DISCRIMINATOR: u8 = 2u8;

/// Accounts.
#[derive(Clone, Debug)]
pub struct Take {
	pub taker: solana_pubkey::Pubkey,
	pub mint_a: solana_pubkey::Pubkey,
	pub mint_b: solana_pubkey::Pubkey,
	pub taker_ata_a: solana_pubkey::Pubkey,
	pub taker_ata_b: solana_pubkey::Pubkey,
	pub maker: solana_pubkey::Pubkey,
	pub maker_ata_b: solana_pubkey::Pubkey,
	pub escrow: solana_pubkey::Pubkey,
	pub vault: solana_pubkey::Pubkey,
	pub token_program: solana_pubkey::Pubkey,
	pub system_program: solana_pubkey::Pubkey,
}

impl Take {
	pub fn new(taker: solana_pubkey::Pubkey, mint_a: solana_pubkey::Pubkey, mint_b: solana_pubkey::Pubkey, taker_ata_a: solana_pubkey::Pubkey, taker_ata_b: solana_pubkey::Pubkey, maker: solana_pubkey::Pubkey, maker_ata_b: solana_pubkey::Pubkey, escrow: solana_pubkey::Pubkey, vault: solana_pubkey::Pubkey, token_program: solana_pubkey::Pubkey, system_program: solana_pubkey::Pubkey) -> Self {
		Self {
			taker,
			mint_a,
			mint_b,
			taker_ata_a,
			taker_ata_b,
			maker,
			maker_ata_b,
			escrow,
			vault,
			token_program,
			system_program,
		}
	}

	pub fn instruction(&self, data: TakeInstructionData) -> solana_instruction::Instruction {
		self.instruction_with_remaining_accounts(data, &[])
	}

	#[allow(clippy::arithmetic_side_effects)]
	pub fn instruction_with_remaining_accounts(
		&self,
		data: TakeInstructionData,
		remaining_accounts: &[solana_instruction::AccountMeta],
	) -> solana_instruction::Instruction {
		let mut accounts = Vec::with_capacity(11 + remaining_accounts.len());
		accounts.push(solana_instruction::AccountMeta::new(self.taker, true));
		accounts.push(solana_instruction::AccountMeta::new_readonly(self.mint_a, false));
		accounts.push(solana_instruction::AccountMeta::new_readonly(self.mint_b, false));
		accounts.push(solana_instruction::AccountMeta::new_readonly(self.taker_ata_a, false));
		accounts.push(solana_instruction::AccountMeta::new_readonly(self.taker_ata_b, false));
		accounts.push(solana_instruction::AccountMeta::new_readonly(self.maker, false));
		accounts.push(solana_instruction::AccountMeta::new_readonly(self.maker_ata_b, false));
		accounts.push(solana_instruction::AccountMeta::new(self.escrow, false));
		accounts.push(solana_instruction::AccountMeta::new(self.vault, false));
		accounts.push(solana_instruction::AccountMeta::new_readonly(self.token_program, false));
		accounts.push(solana_instruction::AccountMeta::new_readonly(self.system_program, false));
		accounts.extend_from_slice(remaining_accounts);
		let data = bytemuck::bytes_of(&data).to_vec();

		solana_instruction::Instruction {
			program_id: crate::ESCROW_PROGRAM_ID,
			accounts,
			data,
		}
	}
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, bytemuck::Pod, bytemuck::Zeroable)]
pub struct TakeInstructionData {
	pub discriminator: u8,
}

impl TakeInstructionData {
	pub const fn new() -> Self {
		Self {
			discriminator: TAKE_DISCRIMINATOR,
		}
	}
}
