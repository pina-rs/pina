use std::fs;
use std::path::Path;
use std::path::PathBuf;

use heck::ToUpperCamelCase;

/// Errors produced during project initialization.
#[derive(Debug, thiserror::Error)]
pub enum InitError {
	#[error("invalid package name `{name}`")]
	InvalidPackageName { name: String },

	#[error("refusing to overwrite existing file: {path}")]
	DestinationExists { path: PathBuf },

	#[error("IO error at {path}: {source}")]
	Io {
		path: PathBuf,
		source: std::io::Error,
	},
}

/// Initialize a new Pina program project in `project_dir`.
///
/// When `force` is `false`, this function fails if any scaffold file already
/// exists. When `true`, scaffold files are overwritten.
pub fn init_project(project_dir: &Path, package_name: &str, force: bool) -> Result<(), InitError> {
	if !is_valid_package_name(package_name) {
		return Err(InitError::InvalidPackageName {
			name: package_name.to_owned(),
		});
	}

	fs::create_dir_all(project_dir).map_err(|source| {
		InitError::Io {
			path: project_dir.to_path_buf(),
			source,
		}
	})?;

	let lib_path = project_dir.join("src/lib.rs");
	let cargo_path = project_dir.join("Cargo.toml");
	let readme_path = project_dir.join("README.md");
	let gitignore_path = project_dir.join(".gitignore");

	let all_paths = [cargo_path, readme_path, gitignore_path, lib_path];
	if !force {
		for path in &all_paths {
			if path.exists() {
				return Err(InitError::DestinationExists { path: path.clone() });
			}
		}
	}

	let src_dir = project_dir.join("src");
	fs::create_dir_all(&src_dir).map_err(|source| {
		InitError::Io {
			path: src_dir,
			source,
		}
	})?;

	let program_title = package_name.replace(['-', '_'], " ").to_upper_camel_case();
	write_file(&all_paths[0], &cargo_toml_template(package_name))?;
	write_file(&all_paths[1], &readme_template(package_name))?;
	write_file(&all_paths[2], &gitignore_template())?;
	write_file(&all_paths[3], &lib_template(package_name, &program_title))?;

	Ok(())
}

fn is_valid_package_name(name: &str) -> bool {
	if name.is_empty() {
		return false;
	}

	if name == "." || name == ".." {
		return false;
	}

	if name.contains('/') || name.contains('\\') || name.chars().any(char::is_whitespace) {
		return false;
	}

	name.chars()
		.all(|ch| ch.is_ascii_alphanumeric() || ch == '-' || ch == '_')
}

fn write_file(path: &Path, contents: &str) -> Result<(), InitError> {
	fs::write(path, contents).map_err(|source| {
		InitError::Io {
			path: path.to_path_buf(),
			source,
		}
	})
}

fn cargo_toml_template(package_name: &str) -> String {
	format!(
		r#"[package]
name = "{package_name}"
version = "0.1.0"
edition = "2024"
publish = false

[lib]
crate-type = ["cdylib", "lib"]

[features]
bpf-entrypoint = []

[dependencies]
pina = {{ version = "0.2", features = ["logs", "derive"] }}
"#
	)
}

fn readme_template(package_name: &str) -> String {
	format!(
		r"# {package_name}

Generated by `pina init`.

## Development

- Build: `cargo build`
- Build (all features): `cargo build --all-features`
- Test: `cargo test`

## IDL

Generate Codama IDL JSON:

```bash
pina idl --path .
```
"
	)
}

fn gitignore_template() -> String {
	"target/\n.DS_Store\n".to_owned()
}

fn lib_template(package_name: &str, program_title: &str) -> String {
	format!(
		r#"//! {program_title} â€” starter Pina program generated by `pina init`.

#![allow(clippy::inline_always)]
#![no_std]

#[cfg(all(
	not(any(target_os = "solana", target_arch = "bpf")),
	not(feature = "bpf-entrypoint"),
	not(test)
))]
extern crate std;

use pina::*;

// Replace this with your deployed program address.
declare_id!("11111111111111111111111111111111");

#[discriminator]
pub enum {program_title}Instruction {{
	Initialize = 0,
}}

#[instruction(discriminator = {program_title}Instruction, variant = Initialize)]
pub struct InitializeInstruction {{}}

#[derive(Accounts, Debug)]
pub struct InitializeAccounts<'a> {{
	pub authority: &'a AccountView,
}}

impl<'a> ProcessAccountInfos<'a> for InitializeAccounts<'a> {{
	fn process(&self, data: &[u8]) -> ProgramResult {{
		let _ = InitializeInstruction::try_from_bytes(data)?;
		self.authority.assert_signer()?;
		log!("Initialized {package_name}");
		Ok(())
	}}
}}

#[cfg(feature = "bpf-entrypoint")]
pub mod entrypoint {{
	use super::*;
	use pina::*;

	nostd_entrypoint!(process_instruction);

	#[inline(always)]
	pub fn process_instruction(
		program_id: &Address,
		accounts: &[AccountView],
		data: &[u8],
	) -> ProgramResult {{
		let instruction: {program_title}Instruction = parse_instruction(program_id, &ID, data)?;
		match instruction {{
			{program_title}Instruction::Initialize => InitializeAccounts::try_from(accounts)?.process(data),
		}}
	}}
}}
"#
	)
}

#[cfg(test)]
mod tests {
	use super::*;

	struct TempDir {
		path: PathBuf,
	}

	impl TempDir {
		fn new(prefix: &str) -> Self {
			let timestamp = std::time::SystemTime::now()
				.duration_since(std::time::UNIX_EPOCH)
				.map_or(0, |duration| duration.as_nanos());
			let path = std::env::temp_dir().join(format!(
				"pina_cli_{prefix}_{}_{}",
				std::process::id(),
				timestamp
			));
			Self { path }
		}
	}

	impl Drop for TempDir {
		fn drop(&mut self) {
			let _ = fs::remove_dir_all(&self.path);
		}
	}

	#[test]
	fn init_project_creates_scaffold() {
		let dir = TempDir::new("create");
		init_project(&dir.path, "my_program", false)
			.unwrap_or_else(|err| panic!("expected init to succeed: {err}"));

		for rel_path in ["Cargo.toml", "README.md", ".gitignore", "src/lib.rs"] {
			assert!(
				dir.path.join(rel_path).exists(),
				"expected scaffold file to exist: {rel_path}"
			);
		}

		let cargo = fs::read_to_string(dir.path.join("Cargo.toml"))
			.unwrap_or_else(|err| panic!("expected Cargo.toml to be readable: {err}"));
		assert!(cargo.contains("name = \"my_program\""));
	}

	#[test]
	fn init_project_refuses_existing_files_without_force() {
		let dir = TempDir::new("exists");
		fs::create_dir_all(&dir.path)
			.unwrap_or_else(|err| panic!("expected temp dir creation to succeed: {err}"));
		fs::write(
			dir.path.join("Cargo.toml"),
			"[package]\nname = \"existing\"",
		)
		.unwrap_or_else(|err| panic!("expected seed file write to succeed: {err}"));

		let result = init_project(&dir.path, "my_program", false);
		match result {
			Err(InitError::DestinationExists { path }) => {
				assert!(path.ends_with("Cargo.toml"));
			}
			other => panic!("expected DestinationExists error, got: {other:?}"),
		}
	}

	#[test]
	fn init_project_overwrites_when_force_enabled() {
		let dir = TempDir::new("force");
		fs::create_dir_all(dir.path.join("src"))
			.unwrap_or_else(|err| panic!("expected src dir creation to succeed: {err}"));
		fs::write(dir.path.join("Cargo.toml"), "invalid")
			.unwrap_or_else(|err| panic!("expected initial Cargo.toml write to succeed: {err}"));
		fs::write(dir.path.join("src/lib.rs"), "invalid")
			.unwrap_or_else(|err| panic!("expected initial lib.rs write to succeed: {err}"));

		init_project(&dir.path, "my_program", true)
			.unwrap_or_else(|err| panic!("expected forced init to succeed: {err}"));

		let cargo = fs::read_to_string(dir.path.join("Cargo.toml"))
			.unwrap_or_else(|err| panic!("expected Cargo.toml to be readable: {err}"));
		assert!(cargo.contains("name = \"my_program\""));
		assert!(!cargo.contains("invalid"));
	}

	#[test]
	fn init_project_rejects_invalid_name() {
		let dir = TempDir::new("invalid_name");
		let result = init_project(&dir.path, "not valid", false);
		assert!(matches!(result, Err(InitError::InvalidPackageName { .. })));
	}
}
