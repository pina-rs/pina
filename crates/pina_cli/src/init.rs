use std::fs;
use std::path::Path;
use std::path::PathBuf;

use heck::ToUpperCamelCase;

/// Errors produced during project initialization.
#[derive(Debug, thiserror::Error)]
pub enum InitError {
	#[error("invalid package name `{name}`")]
	InvalidPackageName { name: String },

	#[error("refusing to overwrite existing file: {path}")]
	DestinationExists { path: PathBuf },

	#[error("IO error at {path}: {source}")]
	Io {
		path: PathBuf,
		source: std::io::Error,
	},
}

/// All scaffold files generated by `pina init`, expressed as relative paths.
const SCAFFOLD_FILES: &[&str] = &[
	"Cargo.toml",
	"README.md",
	".gitignore",
	".cargo/config.toml",
	"src/lib.rs",
	"src/entrypoint.rs",
	"tests/integration.rs",
];

/// Initialize a new Pina program project in `project_dir`.
///
/// When `force` is `false`, this function fails if any scaffold file already
/// exists. When `true`, scaffold files are overwritten.
pub fn init_project(project_dir: &Path, package_name: &str, force: bool) -> Result<(), InitError> {
	if !is_valid_package_name(package_name) {
		return Err(InitError::InvalidPackageName {
			name: package_name.to_owned(),
		});
	}

	// Resolve all destination paths up-front.
	let paths: Vec<PathBuf> = SCAFFOLD_FILES
		.iter()
		.map(|rel| project_dir.join(rel))
		.collect();

	// Check for existing files before writing anything.
	if !force {
		for path in &paths {
			if path.exists() {
				return Err(InitError::DestinationExists { path: path.clone() });
			}
		}
	}

	// Ensure all required directories exist.
	for dir in [
		project_dir.to_path_buf(),
		project_dir.join("src"),
		project_dir.join("tests"),
		project_dir.join(".cargo"),
	] {
		fs::create_dir_all(&dir).map_err(|source| InitError::Io { path: dir, source })?;
	}

	let program_title = package_name.replace(['-', '_'], " ").to_upper_camel_case();

	write_file(&paths[0], &cargo_toml_template(package_name))?;
	write_file(&paths[1], &readme_template(package_name))?;
	write_file(&paths[2], &gitignore_template())?;
	write_file(&paths[3], &cargo_config_template(package_name))?;
	write_file(&paths[4], &lib_template(package_name, &program_title))?;
	write_file(&paths[5], &entrypoint_template(&program_title))?;
	write_file(
		&paths[6],
		&integration_test_template(package_name, &program_title),
	)?;

	Ok(())
}

/// Print next-steps guidance to stdout.
pub fn print_next_steps(project_dir: &Path, package_name: &str) {
	println!();
	println!("  Next steps:");
	println!();
	println!("    cd {}", project_dir.display());
	println!("    cargo build                    # build the library");
	println!("    cargo build --release \\",);
	println!("      --target bpfel-unknown-none \\",);
	println!("      -p {package_name} \\",);
	println!("      -Z build-std -F bpf-entrypoint  # build for SBF",);
	println!("    cargo test                     # run tests");
	println!("    pina idl --path .              # generate Codama IDL JSON");
	println!();
	println!("  Update the program address in src/lib.rs with your deployed program ID.",);
	println!();
}

fn is_valid_package_name(name: &str) -> bool {
	if name.is_empty() {
		return false;
	}

	if name == "." || name == ".." {
		return false;
	}

	if name.contains('/') || name.contains('\\') || name.chars().any(char::is_whitespace) {
		return false;
	}

	name.chars()
		.all(|ch| ch.is_ascii_alphanumeric() || ch == '-' || ch == '_')
}

fn write_file(path: &Path, contents: &str) -> Result<(), InitError> {
	fs::write(path, contents).map_err(|source| {
		InitError::Io {
			path: path.to_path_buf(),
			source,
		}
	})
}

fn cargo_toml_template(package_name: &str) -> String {
	format!(
		r#"[package]
name = "{package_name}"
version = "0.1.0"
edition = "2024"
publish = false

[lib]
crate-type = ["cdylib", "lib"]

[features]
bpf-entrypoint = []

[dependencies]
pina = {{ version = "0.5.0", features = ["logs", "derive"] }}

[dev-dependencies]
mollusk-svm = "0.0.14"
"#
	)
}

fn readme_template(package_name: &str) -> String {
	format!(
		r"# {package_name}

Generated by `pina init`.

## Development

- Build: `cargo build`
- Build (all features): `cargo build --all-features`
- Test: `cargo test`

## IDL

Generate Codama IDL JSON:

```bash
pina idl --path .
```
"
	)
}

fn gitignore_template() -> String {
	"target/\n.DS_Store\n".to_owned()
}

fn cargo_config_template(package_name: &str) -> String {
	format!(
		r#"[target.bpfel-unknown-none]
rustflags = [
	"-C",
	"linker=sbpf-linker",
	"-C",
	"panic=abort",
	"-C",
	"save-temps",
	"-C",
	"link-arg=--llvm-args=-bpf-stack-size=4096",
	"-C",
	"relocation-model=static",
]

[alias]
build-program = "build --release --target bpfel-unknown-none -p {package_name} -Z build-std -F bpf-entrypoint"
"#
	)
}

fn lib_template(package_name: &str, program_title: &str) -> String {
	format!(
		r#"//! {program_title} â€” starter Pina program generated by `pina init`.

#![allow(clippy::inline_always)]
#![no_std]

#[cfg(all(
	not(any(target_os = "solana", target_arch = "bpf")),
	not(feature = "bpf-entrypoint"),
	not(test)
))]
extern crate std;

#[cfg(feature = "bpf-entrypoint")]
pub mod entrypoint;

use pina::*;

// Replace this with your deployed program address.
declare_id!("11111111111111111111111111111111");

#[discriminator]
pub enum {program_title}Instruction {{
	Initialize = 0,
}}

#[instruction(discriminator = {program_title}Instruction, variant = Initialize)]
pub struct InitializeInstruction {{
	pub value: u8,
}}

#[derive(Accounts, Debug)]
pub struct InitializeAccounts<'a> {{
	pub payer: &'a AccountView,
	pub state: &'a AccountView,
	pub system_program: &'a AccountView,
}}

impl<'a> ProcessAccountInfos<'a> for InitializeAccounts<'a> {{
	fn process(&self, data: &[u8]) -> ProgramResult {{
		let _args = InitializeInstruction::try_from_bytes(data)?;
		self.payer.assert_signer()?;
		log!("Initialized {package_name}");
		// Your logic here
		Ok(())
	}}
}}

pub fn process_instruction(
	program_id: &Address,
	accounts: &[AccountView],
	data: &[u8],
) -> ProgramResult {{
	let instruction: {program_title}Instruction = parse_instruction(program_id, &ID, data)?;
	match instruction {{
		{program_title}Instruction::Initialize => {{
			InitializeAccounts::try_from(accounts)?.process(data)
		}}
	}}
}}
"#
	)
}

fn entrypoint_template(program_title: &str) -> String {
	format!(
		r"use pina::*;

use crate::*;

nostd_entrypoint!(process_instruction);

#[inline(always)]
pub fn process_instruction(
	program_id: &Address,
	accounts: &[AccountView],
	data: &[u8],
) -> ProgramResult {{
	let instruction: {program_title}Instruction = parse_instruction(program_id, &ID, data)?;
	match instruction {{
		{program_title}Instruction::Initialize => {{
			InitializeAccounts::try_from(accounts)?.process(data)
		}}
	}}
}}
"
	)
}

fn integration_test_template(package_name: &str, program_title: &str) -> String {
	let package_ident = package_name.replace('-', "_");
	format!(
		r#"use {package_ident}::*;

/// Smoke test: verify that the instruction discriminator is stable.
#[test]
fn instruction_discriminators_are_stable() {{
	assert_eq!({program_title}Instruction::Initialize as u8, 0);
}}

/// Smoke test: parse_instruction rejects a mismatched program ID.
#[test]
fn parse_instruction_rejects_wrong_program_id() {{
	let wrong_id: pina::Address = [9u8; 32].into();
	let data = [{program_title}Instruction::Initialize as u8];
	let result =
		pina::parse_instruction::<{program_title}Instruction>(&wrong_id, &ID, &data);
	assert!(matches!(result, Err(pina::ProgramError::IncorrectProgramId)));
}}

// Uncomment and adapt once mollusk-svm is set up in your environment:
//
// #[test]
// fn initialize_succeeds() {{
//     use mollusk_svm::Mollusk;
//
//     let mollusk = Mollusk::new(&ID, "{package_ident}");
//
//     // Build instruction data (discriminator + payload).
//     let data = [
//         {program_title}Instruction::Initialize as u8,
//         42u8, // value
//     ];
//
//     // Set up account fixtures and invoke via mollusk.process_instruction.
//     // See the mollusk-svm documentation for details.
// }}
"#
	)
}

#[cfg(test)]
mod tests {
	use super::*;

	struct TempDir {
		path: PathBuf,
	}

	impl TempDir {
		fn new(prefix: &str) -> Self {
			let timestamp = std::time::SystemTime::now()
				.duration_since(std::time::UNIX_EPOCH)
				.map_or(0, |duration| duration.as_nanos());
			let path = std::env::temp_dir().join(format!(
				"pina_cli_{prefix}_{}_{}",
				std::process::id(),
				timestamp
			));
			Self { path }
		}
	}

	impl Drop for TempDir {
		fn drop(&mut self) {
			let _ = fs::remove_dir_all(&self.path);
		}
	}

	#[test]
	fn init_project_creates_scaffold() {
		let dir = TempDir::new("create");
		init_project(&dir.path, "my_program", false)
			.unwrap_or_else(|err| panic!("expected init to succeed: {err}"));

		for rel_path in SCAFFOLD_FILES {
			assert!(
				dir.path.join(rel_path).exists(),
				"expected scaffold file to exist: {rel_path}"
			);
		}

		let cargo = fs::read_to_string(dir.path.join("Cargo.toml"))
			.unwrap_or_else(|err| panic!("expected Cargo.toml to be readable: {err}"));
		assert!(cargo.contains("name = \"my_program\""));
		assert!(cargo.contains("pina = { version = \"0.5.0\""));
		assert!(cargo.contains("mollusk-svm"));
	}

	#[test]
	fn init_project_creates_entrypoint() {
		let dir = TempDir::new("entrypoint");
		init_project(&dir.path, "my_program", false)
			.unwrap_or_else(|err| panic!("expected init to succeed: {err}"));

		let entrypoint = fs::read_to_string(dir.path.join("src/entrypoint.rs"))
			.unwrap_or_else(|err| panic!("expected entrypoint.rs to be readable: {err}"));
		assert!(entrypoint.contains("nostd_entrypoint!"));
		assert!(entrypoint.contains("MyProgramInstruction"));
	}

	#[test]
	fn init_project_creates_cargo_config() {
		let dir = TempDir::new("cargo_config");
		init_project(&dir.path, "my_program", false)
			.unwrap_or_else(|err| panic!("expected init to succeed: {err}"));

		let config = fs::read_to_string(dir.path.join(".cargo/config.toml"))
			.unwrap_or_else(|err| panic!("expected .cargo/config.toml to be readable: {err}"));
		assert!(config.contains("[target.bpfel-unknown-none]"));
		assert!(config.contains("sbpf-linker"));
	}

	#[test]
	fn init_project_creates_integration_test() {
		let dir = TempDir::new("integration");
		init_project(&dir.path, "my_program", false)
			.unwrap_or_else(|err| panic!("expected init to succeed: {err}"));

		let test = fs::read_to_string(dir.path.join("tests/integration.rs"))
			.unwrap_or_else(|err| panic!("expected integration.rs to be readable: {err}"));
		assert!(test.contains("use my_program::*;"));
		assert!(test.contains("instruction_discriminators_are_stable"));
		assert!(test.contains("mollusk"));
	}

	#[test]
	fn init_project_lib_references_entrypoint_module() {
		let dir = TempDir::new("lib_entrypoint");
		init_project(&dir.path, "my_program", false)
			.unwrap_or_else(|err| panic!("expected init to succeed: {err}"));

		let lib = fs::read_to_string(dir.path.join("src/lib.rs"))
			.unwrap_or_else(|err| panic!("expected lib.rs to be readable: {err}"));
		assert!(lib.contains("pub mod entrypoint;"));
		assert!(lib.contains("process_instruction"));
	}

	#[test]
	fn init_project_refuses_existing_files_without_force() {
		let dir = TempDir::new("exists");
		fs::create_dir_all(&dir.path)
			.unwrap_or_else(|err| panic!("expected temp dir creation to succeed: {err}"));
		fs::write(
			dir.path.join("Cargo.toml"),
			"[package]\nname = \"existing\"",
		)
		.unwrap_or_else(|err| panic!("expected seed file write to succeed: {err}"));

		let result = init_project(&dir.path, "my_program", false);
		match result {
			Err(InitError::DestinationExists { path }) => {
				assert!(path.ends_with("Cargo.toml"));
			}
			other => panic!("expected DestinationExists error, got: {other:?}"),
		}
	}

	#[test]
	fn init_project_overwrites_when_force_enabled() {
		let dir = TempDir::new("force");
		fs::create_dir_all(dir.path.join("src"))
			.unwrap_or_else(|err| panic!("expected src dir creation to succeed: {err}"));
		fs::write(dir.path.join("Cargo.toml"), "invalid")
			.unwrap_or_else(|err| panic!("expected initial Cargo.toml write to succeed: {err}"));
		fs::write(dir.path.join("src/lib.rs"), "invalid")
			.unwrap_or_else(|err| panic!("expected initial lib.rs write to succeed: {err}"));

		init_project(&dir.path, "my_program", true)
			.unwrap_or_else(|err| panic!("expected forced init to succeed: {err}"));

		let cargo = fs::read_to_string(dir.path.join("Cargo.toml"))
			.unwrap_or_else(|err| panic!("expected Cargo.toml to be readable: {err}"));
		assert!(cargo.contains("name = \"my_program\""));
		assert!(!cargo.contains("invalid"));
	}

	#[test]
	fn init_project_rejects_invalid_name() {
		let dir = TempDir::new("invalid_name");
		let result = init_project(&dir.path, "not valid", false);
		assert!(matches!(result, Err(InitError::InvalidPackageName { .. })));
	}

	#[test]
	fn init_project_handles_hyphenated_name() {
		let dir = TempDir::new("hyphen");
		init_project(&dir.path, "my-cool-program", false)
			.unwrap_or_else(|err| panic!("expected init to succeed: {err}"));

		let lib = fs::read_to_string(dir.path.join("src/lib.rs"))
			.unwrap_or_else(|err| panic!("expected lib.rs to be readable: {err}"));
		// Hyphenated name should produce CamelCase title.
		assert!(lib.contains("MyCoolProgramInstruction"));

		let test = fs::read_to_string(dir.path.join("tests/integration.rs"))
			.unwrap_or_else(|err| panic!("expected integration.rs to be readable: {err}"));
		// The `use` import should use underscores (Rust ident).
		assert!(test.contains("use my_cool_program::*;"));
	}
}
