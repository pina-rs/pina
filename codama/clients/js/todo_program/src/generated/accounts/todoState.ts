/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fixDecoderSize, fixEncoderSize, getAddressDecoder, getAddressEncoder, getBooleanDecoder, getBooleanEncoder, getBytesDecoder, getBytesEncoder, getStructDecoder, getStructEncoder, getU8Decoder, getU8Encoder, type Account, type Address, type EncodedAccount, type FetchAccountConfig, type FetchAccountsConfig, type FixedSizeCodec, type FixedSizeDecoder, type FixedSizeEncoder, type MaybeAccount, type MaybeEncodedAccount, type ReadonlyUint8Array } from '@solana/kit';

export const TODO_STATE_DISCRIMINATOR = 1;

export function getTodoStateDiscriminatorBytes() { return getU8Encoder().encode(TODO_STATE_DISCRIMINATOR); }

export type TodoState = { owner: Address; bump: number; completed: boolean; digest: ReadonlyUint8Array;  };

export type TodoStateArgs = TodoState;

/** Gets the encoder for {@link TodoStateArgs} account data. */
export function getTodoStateEncoder(): FixedSizeEncoder<TodoStateArgs> {
    return getStructEncoder([['owner', getAddressEncoder()], ['bump', getU8Encoder()], ['completed', getBooleanEncoder()], ['digest', fixEncoderSize(getBytesEncoder(), 32)]]);
}

/** Gets the decoder for {@link TodoState} account data. */
export function getTodoStateDecoder(): FixedSizeDecoder<TodoState> {
    return getStructDecoder([['owner', getAddressDecoder()], ['bump', getU8Decoder()], ['completed', getBooleanDecoder()], ['digest', fixDecoderSize(getBytesDecoder(), 32)]]);
}

/** Gets the codec for {@link TodoState} account data. */
export function getTodoStateCodec(): FixedSizeCodec<TodoStateArgs, TodoState> {
    return combineCodec(getTodoStateEncoder(), getTodoStateDecoder());
}

export function decodeTodoState<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<TodoState, TAddress>;
export function decodeTodoState<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<TodoState, TAddress>;
export function decodeTodoState<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>): Account<TodoState, TAddress> | MaybeAccount<TodoState, TAddress> {
  return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getTodoStateDecoder());
}

export async function fetchTodoState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<TodoState, TAddress>> {
  const maybeAccount = await fetchMaybeTodoState(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeTodoState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<TodoState, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeTodoState(maybeAccount);
}

export async function fetchAllTodoState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<TodoState>[]> {
  const maybeAccounts = await fetchAllMaybeTodoState(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeTodoState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<TodoState>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeTodoState(maybeAccount));
}