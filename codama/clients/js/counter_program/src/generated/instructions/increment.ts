/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { getU8Encoder, SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS, SolanaError, type AccountMeta, type AccountSignerMeta, type Address, type Instruction, type InstructionWithAccounts, type ReadonlySignerAccount, type TransactionSigner, type WritableAccount } from '@solana/kit';
import { getAccountMetaFactory, type ResolvedInstructionAccount } from '@solana/program-client-core';
import { COUNTER_PROGRAM_PROGRAM_ADDRESS } from '../programs';

export const INCREMENT_DISCRIMINATOR = 1;

export function getIncrementDiscriminatorBytes() { return getU8Encoder().encode(INCREMENT_DISCRIMINATOR); }

export type IncrementInstruction<TProgram extends string = typeof COUNTER_PROGRAM_PROGRAM_ADDRESS, TAccountAuthority extends string | AccountMeta<string> = string, TAccountCounter extends string | AccountMeta<string> = string, TRemainingAccounts extends readonly AccountMeta<string>[] = []> =
Instruction<TProgram> & InstructionWithAccounts<[TAccountAuthority extends string ? ReadonlySignerAccount<TAccountAuthority> & AccountSignerMeta<TAccountAuthority> : TAccountAuthority, TAccountCounter extends string ? WritableAccount<TAccountCounter> : TAccountCounter, ...TRemainingAccounts]>;

export type IncrementInput<TAccountAuthority extends string = string, TAccountCounter extends string = string> =  {
  /** The counter's authority. Must sign to prove ownership. */
authority: TransactionSigner<TAccountAuthority>;
/** The counter PDA account (must already exist and be writable). */
counter: Address<TAccountCounter>;
}

export function getIncrementInstruction<TAccountAuthority extends string, TAccountCounter extends string, TProgramAddress extends Address = typeof COUNTER_PROGRAM_PROGRAM_ADDRESS>(input: IncrementInput<TAccountAuthority, TAccountCounter>, config?: { programAddress?: TProgramAddress } ): IncrementInstruction<TProgramAddress, TAccountAuthority, TAccountCounter> {
  // Program address.
const programAddress = config?.programAddress ?? COUNTER_PROGRAM_PROGRAM_ADDRESS;

 // Original accounts.
const originalAccounts = { authority: { value: input.authority ?? null, isWritable: false }, counter: { value: input.counter ?? null, isWritable: true } }
const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedInstructionAccount>;




const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
return Object.freeze({ accounts: [getAccountMeta("authority", accounts.authority), getAccountMeta("counter", accounts.counter)], programAddress } as IncrementInstruction<TProgramAddress, TAccountAuthority, TAccountCounter>);
}

export type ParsedIncrementInstruction<TProgram extends string = typeof COUNTER_PROGRAM_PROGRAM_ADDRESS, TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[]> = { programAddress: Address<TProgram>;
accounts: {
/** The counter's authority. Must sign to prove ownership. */
authority: TAccountMetas[0];
/** The counter PDA account (must already exist and be writable). */
counter: TAccountMetas[1];
}; };

export function parseIncrementInstruction<TProgram extends string, TAccountMetas extends readonly AccountMeta[]>(instruction: Instruction<TProgram> & InstructionWithAccounts<TAccountMetas>): ParsedIncrementInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 2) {
  throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS, { actualAccountMetas: instruction.accounts.length, expectedAccountMetas: 2 });
}
let accountIndex = 0;
const getNextAccount = () => {
  const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
  accountIndex += 1;
  return accountMeta;
}
  return { programAddress: instruction.programAddress, accounts: { authority: getNextAccount(), counter: getNextAccount() } };
}