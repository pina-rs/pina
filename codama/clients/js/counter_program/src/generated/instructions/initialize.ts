/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type AccountMeta,
	type AccountSignerMeta,
	type Address,
	combineCodec,
	type FixedSizeCodec,
	type FixedSizeDecoder,
	type FixedSizeEncoder,
	getStructDecoder,
	getStructEncoder,
	getU8Decoder,
	getU8Encoder,
	type Instruction,
	type InstructionWithAccounts,
	type InstructionWithData,
	type ReadonlyAccount,
	type ReadonlySignerAccount,
	type ReadonlyUint8Array,
	SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS,
	SolanaError,
	type TransactionSigner,
	type WritableAccount,
} from "@solana/kit";
import {
	getAccountMetaFactory,
	type ResolvedInstructionAccount,
} from "@solana/program-client-core";
import { COUNTER_PROGRAM_PROGRAM_ADDRESS } from "../programs";

export const INITIALIZE_DISCRIMINATOR = 0;

export function getInitializeDiscriminatorBytes() {
	return getU8Encoder().encode(INITIALIZE_DISCRIMINATOR);
}

export type InitializeInstruction<
	TProgram extends string = typeof COUNTER_PROGRAM_PROGRAM_ADDRESS,
	TAccountAuthority extends string | AccountMeta<string> = string,
	TAccountCounter extends string | AccountMeta<string> = string,
	TAccountSystemProgram extends string | AccountMeta<string> =
		"11111111111111111111111111111111",
	TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> =
	& Instruction<TProgram>
	& InstructionWithData<ReadonlyUint8Array>
	& InstructionWithAccounts<
		[
			TAccountAuthority extends string ?
					& ReadonlySignerAccount<TAccountAuthority>
					& AccountSignerMeta<TAccountAuthority>
				: TAccountAuthority,
			TAccountCounter extends string ? WritableAccount<TAccountCounter>
				: TAccountCounter,
			TAccountSystemProgram extends string
				? ReadonlyAccount<TAccountSystemProgram>
				: TAccountSystemProgram,
			...TRemainingAccounts,
		]
	>;

export type InitializeInstructionData = { bump: number };

export type InitializeInstructionDataArgs = InitializeInstructionData;

export function getInitializeInstructionDataEncoder(): FixedSizeEncoder<
	InitializeInstructionDataArgs
> {
	return getStructEncoder([["bump", getU8Encoder()]]);
}

export function getInitializeInstructionDataDecoder(): FixedSizeDecoder<
	InitializeInstructionData
> {
	return getStructDecoder([["bump", getU8Decoder()]]);
}

export function getInitializeInstructionDataCodec(): FixedSizeCodec<
	InitializeInstructionDataArgs,
	InitializeInstructionData
> {
	return combineCodec(
		getInitializeInstructionDataEncoder(),
		getInitializeInstructionDataDecoder(),
	);
}

export type InitializeInput<
	TAccountAuthority extends string = string,
	TAccountCounter extends string = string,
	TAccountSystemProgram extends string = string,
> = {
	/**
	 * The wallet creating the counter. Pays for account creation and becomes
	 * the authority whose address seeds the PDA.
	 */
	authority: TransactionSigner<TAccountAuthority>;
	/** The counter PDA account (must be empty — not yet created). */
	counter: Address<TAccountCounter>;
	/** The system program, required for `CreateAccount` CPI. */
	systemProgram?: Address<TAccountSystemProgram>;
	bump: InitializeInstructionDataArgs["bump"];
};

export function getInitializeInstruction<
	TAccountAuthority extends string,
	TAccountCounter extends string,
	TAccountSystemProgram extends string,
	TProgramAddress extends Address = typeof COUNTER_PROGRAM_PROGRAM_ADDRESS,
>(
	input: InitializeInput<
		TAccountAuthority,
		TAccountCounter,
		TAccountSystemProgram
	>,
	config?: { programAddress?: TProgramAddress },
): InitializeInstruction<
	TProgramAddress,
	TAccountAuthority,
	TAccountCounter,
	TAccountSystemProgram
> {
	// Program address.
	const programAddress = config?.programAddress ??
		COUNTER_PROGRAM_PROGRAM_ADDRESS;

	// Original accounts.
	const originalAccounts = {
		authority: { value: input.authority ?? null, isWritable: false },
		counter: { value: input.counter ?? null, isWritable: true },
		systemProgram: { value: input.systemProgram ?? null, isWritable: false },
	};
	const accounts = originalAccounts as Record<
		keyof typeof originalAccounts,
		ResolvedInstructionAccount
	>;

	// Original args.
	const args = { ...input };

	// Resolve default values.
	if (!accounts.systemProgram.value) {
		accounts.systemProgram.value =
			"11111111111111111111111111111111" as Address<
				"11111111111111111111111111111111"
			>;
	}

	const getAccountMeta = getAccountMetaFactory(programAddress, "programId");
	return Object.freeze({
		accounts: [
			getAccountMeta("authority", accounts.authority),
			getAccountMeta("counter", accounts.counter),
			getAccountMeta("systemProgram", accounts.systemProgram),
		],
		data: getInitializeInstructionDataEncoder().encode(
			args as InitializeInstructionDataArgs,
		),
		programAddress,
	} as InitializeInstruction<
		TProgramAddress,
		TAccountAuthority,
		TAccountCounter,
		TAccountSystemProgram
	>);
}

export type ParsedInitializeInstruction<
	TProgram extends string = typeof COUNTER_PROGRAM_PROGRAM_ADDRESS,
	TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
	programAddress: Address<TProgram>;
	accounts: {
		/**
		 * The wallet creating the counter. Pays for account creation and becomes
		 * the authority whose address seeds the PDA.
		 */
		authority: TAccountMetas[0];
		/** The counter PDA account (must be empty — not yet created). */
		counter: TAccountMetas[1];
		/** The system program, required for `CreateAccount` CPI. */
		systemProgram: TAccountMetas[2];
	};
	data: InitializeInstructionData;
};

export function parseInitializeInstruction<
	TProgram extends string,
	TAccountMetas extends readonly AccountMeta[],
>(
	instruction:
		& Instruction<TProgram>
		& InstructionWithAccounts<TAccountMetas>
		& InstructionWithData<ReadonlyUint8Array>,
): ParsedInitializeInstruction<TProgram, TAccountMetas> {
	if (instruction.accounts.length < 3) {
		throw new SolanaError(
			SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS,
			{
				actualAccountMetas: instruction.accounts.length,
				expectedAccountMetas: 3,
			},
		);
	}
	let accountIndex = 0;
	const getNextAccount = () => {
		const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
		accountIndex += 1;
		return accountMeta;
	};
	return {
		programAddress: instruction.programAddress,
		accounts: {
			authority: getNextAccount(),
			counter: getNextAccount(),
			systemProgram: getNextAccount(),
		},
		data: getInitializeInstructionDataDecoder().decode(instruction.data),
	};
}
