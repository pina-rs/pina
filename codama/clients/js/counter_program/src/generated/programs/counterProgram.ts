/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type Address,
	assertIsInstructionWithAccounts,
	type ClientWithRpc,
	type ClientWithTransactionPlanning,
	type ClientWithTransactionSending,
	containsBytes,
	type GetAccountInfoApi,
	type GetMultipleAccountsApi,
	getU8Encoder,
	type Instruction,
	type InstructionWithData,
	type ReadonlyUint8Array,
	SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
	SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
	SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
	SolanaError,
} from "@solana/kit";
import {
	addSelfFetchFunctions,
	addSelfPlanAndSendFunctions,
	type SelfFetchFunctions,
	type SelfPlanAndSendFunctions,
} from "@solana/program-client-core";
import {
	type CounterState,
	type CounterStateArgs,
	getCounterStateCodec,
} from "../accounts";
import {
	getIncrementInstruction,
	getInitializeInstruction,
	type IncrementInput,
	type InitializeInput,
	type ParsedIncrementInstruction,
	type ParsedInitializeInstruction,
	parseIncrementInstruction,
	parseInitializeInstruction,
} from "../instructions";

export const COUNTER_PROGRAM_PROGRAM_ADDRESS =
	"GJQcuWrT2f3f4KNuJcXhhwUa1ZQTYbxzzJ1hotzKu8hS" as Address<
		"GJQcuWrT2f3f4KNuJcXhhwUa1ZQTYbxzzJ1hotzKu8hS"
	>;

export enum CounterProgramAccount {
	CounterState,
}

export function identifyCounterProgramAccount(
	account: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): CounterProgramAccount {
	const data = "data" in account ? account.data : account;
	if (containsBytes(data, getU8Encoder().encode(1), 0)) {
		return CounterProgramAccount.CounterState;
	}
	throw new SolanaError(
		SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT,
		{ accountData: data, programName: "counterProgram" },
	);
}

export enum CounterProgramInstruction {
	Initialize,
	Increment,
}

export function identifyCounterProgramInstruction(
	instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): CounterProgramInstruction {
	const data = "data" in instruction ? instruction.data : instruction;
	if (containsBytes(data, getU8Encoder().encode(0), 0)) {
		return CounterProgramInstruction.Initialize;
	}
	if (containsBytes(data, getU8Encoder().encode(1), 0)) {
		return CounterProgramInstruction.Increment;
	}
	throw new SolanaError(
		SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
		{ instructionData: data, programName: "counterProgram" },
	);
}

export type ParsedCounterProgramInstruction<
	TProgram extends string = "GJQcuWrT2f3f4KNuJcXhhwUa1ZQTYbxzzJ1hotzKu8hS",
> =
	| { instructionType: CounterProgramInstruction.Initialize }
		& ParsedInitializeInstruction<TProgram>
	| { instructionType: CounterProgramInstruction.Increment }
		& ParsedIncrementInstruction<TProgram>;

export function parseCounterProgramInstruction<TProgram extends string>(
	instruction:
		& Instruction<TProgram>
		& InstructionWithData<ReadonlyUint8Array>,
): ParsedCounterProgramInstruction<TProgram> {
	const instructionType = identifyCounterProgramInstruction(instruction);
	switch (instructionType) {
		case CounterProgramInstruction.Initialize: {
			assertIsInstructionWithAccounts(instruction);
			return {
				instructionType: CounterProgramInstruction.Initialize,
				...parseInitializeInstruction(instruction),
			};
		}
		case CounterProgramInstruction.Increment: {
			assertIsInstructionWithAccounts(instruction);
			return {
				instructionType: CounterProgramInstruction.Increment,
				...parseIncrementInstruction(instruction),
			};
		}
		default:
			throw new SolanaError(
				SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
				{
					instructionType: instructionType as string,
					programName: "counterProgram",
				},
			);
	}
}

export type CounterProgramPlugin = {
	accounts: CounterProgramPluginAccounts;
	instructions: CounterProgramPluginInstructions;
};

export type CounterProgramPluginAccounts = {
	counterState:
		& ReturnType<typeof getCounterStateCodec>
		& SelfFetchFunctions<CounterStateArgs, CounterState>;
};

export type CounterProgramPluginInstructions = {
	initialize: (
		input: InitializeInput,
	) => ReturnType<typeof getInitializeInstruction> & SelfPlanAndSendFunctions;
	increment: (
		input: IncrementInput,
	) => ReturnType<typeof getIncrementInstruction> & SelfPlanAndSendFunctions;
};

export type CounterProgramPluginRequirements =
	& ClientWithRpc<GetAccountInfoApi & GetMultipleAccountsApi>
	& ClientWithTransactionPlanning
	& ClientWithTransactionSending;

export function counterProgramProgram() {
	return <T extends CounterProgramPluginRequirements>(client: T) => {
		return {
			...client,
			counterProgram: <CounterProgramPlugin> {
				accounts: {
					counterState: addSelfFetchFunctions(client, getCounterStateCodec()),
				},
				instructions: {
					initialize: (input) =>
						addSelfPlanAndSendFunctions(
							client,
							getInitializeInstruction(input),
						),
					increment: (input) =>
						addSelfPlanAndSendFunctions(client, getIncrementInstruction(input)),
				},
			},
		};
	};
}
