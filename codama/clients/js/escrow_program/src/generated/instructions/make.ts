/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { combineCodec, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, getU8Decoder, getU8Encoder, SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS, SolanaError, type AccountMeta, type AccountSignerMeta, type Address, type FixedSizeCodec, type FixedSizeDecoder, type FixedSizeEncoder, type Instruction, type InstructionWithAccounts, type InstructionWithData, type ReadonlyAccount, type ReadonlySignerAccount, type ReadonlyUint8Array, type TransactionSigner, type WritableAccount } from '@solana/kit';
import { getAccountMetaFactory, type ResolvedInstructionAccount } from '@solana/program-client-core';
import { ESCROW_PROGRAM_PROGRAM_ADDRESS } from '../programs';

export const MAKE_DISCRIMINATOR = 1;

export function getMakeDiscriminatorBytes() { return getU8Encoder().encode(MAKE_DISCRIMINATOR); }

export type MakeInstruction<TProgram extends string = typeof ESCROW_PROGRAM_PROGRAM_ADDRESS, TAccountMaker extends string | AccountMeta<string> = string, TAccountMintA extends string | AccountMeta<string> = string, TAccountMintB extends string | AccountMeta<string> = string, TAccountMakerAtaA extends string | AccountMeta<string> = string, TAccountEscrow extends string | AccountMeta<string> = string, TAccountVault extends string | AccountMeta<string> = string, TAccountSystemProgram extends string | AccountMeta<string> = string, TAccountTokenProgram extends string | AccountMeta<string> = string, TRemainingAccounts extends readonly AccountMeta<string>[] = []> =
Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array> & InstructionWithAccounts<[TAccountMaker extends string ? ReadonlySignerAccount<TAccountMaker> & AccountSignerMeta<TAccountMaker> : TAccountMaker, TAccountMintA extends string ? ReadonlyAccount<TAccountMintA> : TAccountMintA, TAccountMintB extends string ? ReadonlyAccount<TAccountMintB> : TAccountMintB, TAccountMakerAtaA extends string ? ReadonlyAccount<TAccountMakerAtaA> : TAccountMakerAtaA, TAccountEscrow extends string ? WritableAccount<TAccountEscrow> : TAccountEscrow, TAccountVault extends string ? WritableAccount<TAccountVault> : TAccountVault, TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram, TAccountTokenProgram extends string ? ReadonlyAccount<TAccountTokenProgram> : TAccountTokenProgram, ...TRemainingAccounts]>;

export type MakeInstructionData = { seed: bigint; amountA: bigint; amountB: bigint; bump: number;  };

export type MakeInstructionDataArgs = { seed: number | bigint; amountA: number | bigint; amountB: number | bigint; bump: number;  };

export function getMakeInstructionDataEncoder(): FixedSizeEncoder<MakeInstructionDataArgs> {
    return getStructEncoder([['seed', getU64Encoder()], ['amountA', getU64Encoder()], ['amountB', getU64Encoder()], ['bump', getU8Encoder()]]);
}

export function getMakeInstructionDataDecoder(): FixedSizeDecoder<MakeInstructionData> {
    return getStructDecoder([['seed', getU64Decoder()], ['amountA', getU64Decoder()], ['amountB', getU64Decoder()], ['bump', getU8Decoder()]]);
}

export function getMakeInstructionDataCodec(): FixedSizeCodec<MakeInstructionDataArgs, MakeInstructionData> {
    return combineCodec(getMakeInstructionDataEncoder(), getMakeInstructionDataDecoder());
}

export type MakeInput<TAccountMaker extends string = string, TAccountMintA extends string = string, TAccountMintB extends string = string, TAccountMakerAtaA extends string = string, TAccountEscrow extends string = string, TAccountVault extends string = string, TAccountSystemProgram extends string = string, TAccountTokenProgram extends string = string> =  {
  maker: TransactionSigner<TAccountMaker>;
mintA: Address<TAccountMintA>;
mintB: Address<TAccountMintB>;
makerAtaA: Address<TAccountMakerAtaA>;
escrow: Address<TAccountEscrow>;
vault: Address<TAccountVault>;
systemProgram: Address<TAccountSystemProgram>;
tokenProgram: Address<TAccountTokenProgram>;
seed: MakeInstructionDataArgs["seed"];
amountA: MakeInstructionDataArgs["amountA"];
amountB: MakeInstructionDataArgs["amountB"];
bump: MakeInstructionDataArgs["bump"];
}

export function getMakeInstruction<TAccountMaker extends string, TAccountMintA extends string, TAccountMintB extends string, TAccountMakerAtaA extends string, TAccountEscrow extends string, TAccountVault extends string, TAccountSystemProgram extends string, TAccountTokenProgram extends string, TProgramAddress extends Address = typeof ESCROW_PROGRAM_PROGRAM_ADDRESS>(input: MakeInput<TAccountMaker, TAccountMintA, TAccountMintB, TAccountMakerAtaA, TAccountEscrow, TAccountVault, TAccountSystemProgram, TAccountTokenProgram>, config?: { programAddress?: TProgramAddress } ): MakeInstruction<TProgramAddress, TAccountMaker, TAccountMintA, TAccountMintB, TAccountMakerAtaA, TAccountEscrow, TAccountVault, TAccountSystemProgram, TAccountTokenProgram> {
  // Program address.
const programAddress = config?.programAddress ?? ESCROW_PROGRAM_PROGRAM_ADDRESS;

 // Original accounts.
const originalAccounts = { maker: { value: input.maker ?? null, isWritable: false }, mintA: { value: input.mintA ?? null, isWritable: false }, mintB: { value: input.mintB ?? null, isWritable: false }, makerAtaA: { value: input.makerAtaA ?? null, isWritable: false }, escrow: { value: input.escrow ?? null, isWritable: true }, vault: { value: input.vault ?? null, isWritable: true }, systemProgram: { value: input.systemProgram ?? null, isWritable: false }, tokenProgram: { value: input.tokenProgram ?? null, isWritable: false } }
const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedInstructionAccount>;


// Original args.
const args = { ...input,  };




const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
return Object.freeze({ accounts: [getAccountMeta("maker", accounts.maker), getAccountMeta("mintA", accounts.mintA), getAccountMeta("mintB", accounts.mintB), getAccountMeta("makerAtaA", accounts.makerAtaA), getAccountMeta("escrow", accounts.escrow), getAccountMeta("vault", accounts.vault), getAccountMeta("systemProgram", accounts.systemProgram), getAccountMeta("tokenProgram", accounts.tokenProgram)], data: getMakeInstructionDataEncoder().encode(args as MakeInstructionDataArgs), programAddress } as MakeInstruction<TProgramAddress, TAccountMaker, TAccountMintA, TAccountMintB, TAccountMakerAtaA, TAccountEscrow, TAccountVault, TAccountSystemProgram, TAccountTokenProgram>);
}

export type ParsedMakeInstruction<TProgram extends string = typeof ESCROW_PROGRAM_PROGRAM_ADDRESS, TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[]> = { programAddress: Address<TProgram>;
accounts: {
maker: TAccountMetas[0];
mintA: TAccountMetas[1];
mintB: TAccountMetas[2];
makerAtaA: TAccountMetas[3];
escrow: TAccountMetas[4];
vault: TAccountMetas[5];
systemProgram: TAccountMetas[6];
tokenProgram: TAccountMetas[7];
};
data: MakeInstructionData; };

export function parseMakeInstruction<TProgram extends string, TAccountMetas extends readonly AccountMeta[]>(instruction: Instruction<TProgram> & InstructionWithAccounts<TAccountMetas> & InstructionWithData<ReadonlyUint8Array>): ParsedMakeInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 8) {
  throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS, { actualAccountMetas: instruction.accounts.length, expectedAccountMetas: 8 });
}
let accountIndex = 0;
const getNextAccount = () => {
  const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
  accountIndex += 1;
  return accountMeta;
}
  return { programAddress: instruction.programAddress, accounts: { maker: getNextAccount(), mintA: getNextAccount(), mintB: getNextAccount(), makerAtaA: getNextAccount(), escrow: getNextAccount(), vault: getNextAccount(), systemProgram: getNextAccount(), tokenProgram: getNextAccount() }, data: getMakeInstructionDataDecoder().decode(instruction.data) };
}