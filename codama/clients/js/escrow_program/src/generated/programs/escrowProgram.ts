/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { assertIsInstructionWithAccounts, containsBytes, getU8Encoder, SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT, SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION, SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE, SolanaError, type Address, type ClientWithRpc, type ClientWithTransactionPlanning, type ClientWithTransactionSending, type GetAccountInfoApi, type GetMultipleAccountsApi, type Instruction, type InstructionWithData, type ReadonlyUint8Array } from '@solana/kit';
import { addSelfFetchFunctions, addSelfPlanAndSendFunctions, type SelfFetchFunctions, type SelfPlanAndSendFunctions } from '@solana/program-client-core';
import { getEscrowStateCodec, type EscrowState, type EscrowStateArgs } from '../accounts';
import { getMakeInstruction, getTakeInstruction, parseMakeInstruction, parseTakeInstruction, type MakeInput, type ParsedMakeInstruction, type ParsedTakeInstruction, type TakeInput } from '../instructions';

export const ESCROW_PROGRAM_PROGRAM_ADDRESS = '4ibrEMW5F6hKnkW4jVedswYv6H6VtwPN6ar6dvXDN1nT' as Address<'4ibrEMW5F6hKnkW4jVedswYv6H6VtwPN6ar6dvXDN1nT'>;

export enum EscrowProgramAccount { EscrowState }

export function identifyEscrowProgramAccount(account: { data: ReadonlyUint8Array } | ReadonlyUint8Array): EscrowProgramAccount {
    const data = 'data' in account ? account.data : account;
    if (containsBytes(data, getU8Encoder().encode(1), 0)) { return EscrowProgramAccount.EscrowState; }
    throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT, { accountData: data, programName: "escrowProgram" });
}

export enum EscrowProgramInstruction { Make, Take }

export function identifyEscrowProgramInstruction(instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array): EscrowProgramInstruction {
    const data = 'data' in instruction ? instruction.data : instruction;
    if (containsBytes(data, getU8Encoder().encode(1), 0)) { return EscrowProgramInstruction.Make; }
if (containsBytes(data, getU8Encoder().encode(2), 0)) { return EscrowProgramInstruction.Take; }
    throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION, { instructionData: data, programName: "escrowProgram" });
}

export type ParsedEscrowProgramInstruction<TProgram extends string = '4ibrEMW5F6hKnkW4jVedswYv6H6VtwPN6ar6dvXDN1nT'> =
| { instructionType: EscrowProgramInstruction.Make } & ParsedMakeInstruction<TProgram>
| { instructionType: EscrowProgramInstruction.Take } & ParsedTakeInstruction<TProgram>


        export function parseEscrowProgramInstruction<TProgram extends string>(
            instruction: Instruction<TProgram> 
                & InstructionWithData<ReadonlyUint8Array>
        ): ParsedEscrowProgramInstruction<TProgram> {
            const instructionType = identifyEscrowProgramInstruction(instruction);
            switch (instructionType) {
                case EscrowProgramInstruction.Make: { assertIsInstructionWithAccounts(instruction);
return { instructionType: EscrowProgramInstruction.Make, ...parseMakeInstruction(instruction) }; }
case EscrowProgramInstruction.Take: { assertIsInstructionWithAccounts(instruction);
return { instructionType: EscrowProgramInstruction.Take, ...parseTakeInstruction(instruction) }; }
                default: throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE, { instructionType: instructionType as string, programName: "escrowProgram" });
            }
        }

export type EscrowProgramPlugin = { accounts: EscrowProgramPluginAccounts; instructions: EscrowProgramPluginInstructions; }

export type EscrowProgramPluginAccounts = { escrowState: ReturnType<typeof getEscrowStateCodec> & SelfFetchFunctions<EscrowStateArgs, EscrowState>; }

export type EscrowProgramPluginInstructions = { make: (input: MakeInput) => ReturnType<typeof getMakeInstruction> & SelfPlanAndSendFunctions; take: (input: TakeInput) => ReturnType<typeof getTakeInstruction> & SelfPlanAndSendFunctions; }

export type EscrowProgramPluginRequirements = ClientWithRpc<GetAccountInfoApi & GetMultipleAccountsApi> & ClientWithTransactionPlanning & ClientWithTransactionSending

export function escrowProgramProgram() {
    return <T extends EscrowProgramPluginRequirements>(client: T) => {
        return { ...client, escrowProgram: <EscrowProgramPlugin>{ accounts: { escrowState: addSelfFetchFunctions(client, getEscrowStateCodec()) }, instructions: { make: input => addSelfPlanAndSendFunctions(client, getMakeInstruction(input)), take: input => addSelfPlanAndSendFunctions(client, getTakeInstruction(input)) } } };
    };
}