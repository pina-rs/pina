/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { combineCodec, getStructDecoder, getStructEncoder, getU16Decoder, getU16Encoder, getU8Encoder, SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS, SolanaError, type AccountMeta, type AccountSignerMeta, type Address, type FixedSizeCodec, type FixedSizeDecoder, type FixedSizeEncoder, type Instruction, type InstructionWithAccounts, type InstructionWithData, type ReadonlyAccount, type ReadonlySignerAccount, type ReadonlyUint8Array, type TransactionSigner, type WritableAccount } from '@solana/kit';
import { getAccountMetaFactory, type ResolvedInstructionAccount } from '@solana/program-client-core';
import { ANCHOR_REALLOC_PROGRAM_ADDRESS } from '../programs';

export const REALLOC2_DISCRIMINATOR = 1;

export function getRealloc2DiscriminatorBytes() { return getU8Encoder().encode(REALLOC2_DISCRIMINATOR); }

export type Realloc2Instruction<TProgram extends string = typeof ANCHOR_REALLOC_PROGRAM_ADDRESS, TAccountAuthority extends string | AccountMeta<string> = string, TAccountSample1 extends string | AccountMeta<string> = string, TAccountSample2 extends string | AccountMeta<string> = string, TAccountSystemProgram extends string | AccountMeta<string> = "11111111111111111111111111111111", TRemainingAccounts extends readonly AccountMeta<string>[] = []> =
Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array> & InstructionWithAccounts<[TAccountAuthority extends string ? ReadonlySignerAccount<TAccountAuthority> & AccountSignerMeta<TAccountAuthority> : TAccountAuthority, TAccountSample1 extends string ? WritableAccount<TAccountSample1> : TAccountSample1, TAccountSample2 extends string ? WritableAccount<TAccountSample2> : TAccountSample2, TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram, ...TRemainingAccounts]>;

export type Realloc2InstructionData = { len: number;  };

export type Realloc2InstructionDataArgs = Realloc2InstructionData;

export function getRealloc2InstructionDataEncoder(): FixedSizeEncoder<Realloc2InstructionDataArgs> {
    return getStructEncoder([['len', getU16Encoder()]]);
}

export function getRealloc2InstructionDataDecoder(): FixedSizeDecoder<Realloc2InstructionData> {
    return getStructDecoder([['len', getU16Decoder()]]);
}

export function getRealloc2InstructionDataCodec(): FixedSizeCodec<Realloc2InstructionDataArgs, Realloc2InstructionData> {
    return combineCodec(getRealloc2InstructionDataEncoder(), getRealloc2InstructionDataDecoder());
}

export type Realloc2Input<TAccountAuthority extends string = string, TAccountSample1 extends string = string, TAccountSample2 extends string = string, TAccountSystemProgram extends string = string> =  {
  authority: TransactionSigner<TAccountAuthority>;
sample1: Address<TAccountSample1>;
sample2: Address<TAccountSample2>;
systemProgram?: Address<TAccountSystemProgram>;
len: Realloc2InstructionDataArgs["len"];
}

export function getRealloc2Instruction<TAccountAuthority extends string, TAccountSample1 extends string, TAccountSample2 extends string, TAccountSystemProgram extends string, TProgramAddress extends Address = typeof ANCHOR_REALLOC_PROGRAM_ADDRESS>(input: Realloc2Input<TAccountAuthority, TAccountSample1, TAccountSample2, TAccountSystemProgram>, config?: { programAddress?: TProgramAddress } ): Realloc2Instruction<TProgramAddress, TAccountAuthority, TAccountSample1, TAccountSample2, TAccountSystemProgram> {
  // Program address.
const programAddress = config?.programAddress ?? ANCHOR_REALLOC_PROGRAM_ADDRESS;

 // Original accounts.
const originalAccounts = { authority: { value: input.authority ?? null, isWritable: false }, sample1: { value: input.sample1 ?? null, isWritable: true }, sample2: { value: input.sample2 ?? null, isWritable: true }, systemProgram: { value: input.systemProgram ?? null, isWritable: false } }
const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedInstructionAccount>;


// Original args.
const args = { ...input,  };


// Resolve default values.
if (!accounts.systemProgram.value) {
accounts.systemProgram.value = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
}

const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
return Object.freeze({ accounts: [getAccountMeta("authority", accounts.authority), getAccountMeta("sample1", accounts.sample1), getAccountMeta("sample2", accounts.sample2), getAccountMeta("systemProgram", accounts.systemProgram)], data: getRealloc2InstructionDataEncoder().encode(args as Realloc2InstructionDataArgs), programAddress } as Realloc2Instruction<TProgramAddress, TAccountAuthority, TAccountSample1, TAccountSample2, TAccountSystemProgram>);
}

export type ParsedRealloc2Instruction<TProgram extends string = typeof ANCHOR_REALLOC_PROGRAM_ADDRESS, TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[]> = { programAddress: Address<TProgram>;
accounts: {
authority: TAccountMetas[0];
sample1: TAccountMetas[1];
sample2: TAccountMetas[2];
systemProgram: TAccountMetas[3];
};
data: Realloc2InstructionData; };

export function parseRealloc2Instruction<TProgram extends string, TAccountMetas extends readonly AccountMeta[]>(instruction: Instruction<TProgram> & InstructionWithAccounts<TAccountMetas> & InstructionWithData<ReadonlyUint8Array>): ParsedRealloc2Instruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 4) {
  throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__INSUFFICIENT_ACCOUNT_METAS, { actualAccountMetas: instruction.accounts.length, expectedAccountMetas: 4 });
}
let accountIndex = 0;
const getNextAccount = () => {
  const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
  accountIndex += 1;
  return accountMeta;
}
  return { programAddress: instruction.programAddress, accounts: { authority: getNextAccount(), sample1: getNextAccount(), sample2: getNextAccount(), systemProgram: getNextAccount() }, data: getRealloc2InstructionDataDecoder().decode(instruction.data) };
}