/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { assertAccountExists, assertAccountsExist, combineCodec, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, getAddressDecoder, getAddressEncoder, getStructDecoder, getStructEncoder, getU32Decoder, getU32Encoder, getU64Decoder, getU64Encoder, getU8Encoder, type Account, type Address, type EncodedAccount, type FetchAccountConfig, type FetchAccountsConfig, type FixedSizeCodec, type FixedSizeDecoder, type FixedSizeEncoder, type MaybeAccount, type MaybeEncodedAccount } from '@solana/kit';

export const FLOAT_DATA_ACCOUNT_DISCRIMINATOR = 1;

export function getFloatDataAccountDiscriminatorBytes() { return getU8Encoder().encode(FLOAT_DATA_ACCOUNT_DISCRIMINATOR); }

export type FloatDataAccount = { dataF64: bigint; dataF32: number; authority: Address;  };

export type FloatDataAccountArgs = { dataF64: number | bigint; dataF32: number; authority: Address;  };

/** Gets the encoder for {@link FloatDataAccountArgs} account data. */
export function getFloatDataAccountEncoder(): FixedSizeEncoder<FloatDataAccountArgs> {
    return getStructEncoder([['dataF64', getU64Encoder()], ['dataF32', getU32Encoder()], ['authority', getAddressEncoder()]]);
}

/** Gets the decoder for {@link FloatDataAccount} account data. */
export function getFloatDataAccountDecoder(): FixedSizeDecoder<FloatDataAccount> {
    return getStructDecoder([['dataF64', getU64Decoder()], ['dataF32', getU32Decoder()], ['authority', getAddressDecoder()]]);
}

/** Gets the codec for {@link FloatDataAccount} account data. */
export function getFloatDataAccountCodec(): FixedSizeCodec<FloatDataAccountArgs, FloatDataAccount> {
    return combineCodec(getFloatDataAccountEncoder(), getFloatDataAccountDecoder());
}

export function decodeFloatDataAccount<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress>): Account<FloatDataAccount, TAddress>;
export function decodeFloatDataAccount<TAddress extends string = string>(encodedAccount: MaybeEncodedAccount<TAddress>): MaybeAccount<FloatDataAccount, TAddress>;
export function decodeFloatDataAccount<TAddress extends string = string>(encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>): Account<FloatDataAccount, TAddress> | MaybeAccount<FloatDataAccount, TAddress> {
  return decodeAccount(encodedAccount as MaybeEncodedAccount<TAddress>, getFloatDataAccountDecoder());
}

export async function fetchFloatDataAccount<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<Account<FloatDataAccount, TAddress>> {
  const maybeAccount = await fetchMaybeFloatDataAccount(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeFloatDataAccount<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig,
): Promise<MaybeAccount<FloatDataAccount, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeFloatDataAccount(maybeAccount);
}

export async function fetchAllFloatDataAccount(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<Account<FloatDataAccount>[]> {
  const maybeAccounts = await fetchAllMaybeFloatDataAccount(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeFloatDataAccount(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig,
): Promise<MaybeAccount<FloatDataAccount>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeFloatDataAccount(maybeAccount));
}