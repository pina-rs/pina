/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { assertIsInstructionWithAccounts, containsBytes, getU8Encoder, SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT, SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION, SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE, SolanaError, type Address, type ClientWithRpc, type ClientWithTransactionPlanning, type ClientWithTransactionSending, type GetAccountInfoApi, type GetMultipleAccountsApi, type Instruction, type InstructionWithData, type ReadonlyUint8Array } from '@solana/kit';
import { addSelfFetchFunctions, addSelfPlanAndSendFunctions, type SelfFetchFunctions, type SelfPlanAndSendFunctions } from '@solana/program-client-core';
import { getFloatDataAccountCodec, type FloatDataAccount, type FloatDataAccountArgs } from '../accounts';
import { getCreateInstruction, getUpdateInstruction, parseCreateInstruction, parseUpdateInstruction, type CreateInput, type ParsedCreateInstruction, type ParsedUpdateInstruction, type UpdateInput } from '../instructions';

export const ANCHOR_FLOATS_PROGRAM_ADDRESS = 'Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS' as Address<'Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS'>;

export enum AnchorFloatsAccount { FloatDataAccount }

export function identifyAnchorFloatsAccount(account: { data: ReadonlyUint8Array } | ReadonlyUint8Array): AnchorFloatsAccount {
    const data = 'data' in account ? account.data : account;
    if (containsBytes(data, getU8Encoder().encode(1), 0)) { return AnchorFloatsAccount.FloatDataAccount; }
    throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_ACCOUNT, { accountData: data, programName: "anchorFloats" });
}

export enum AnchorFloatsInstruction { Create, Update }

export function identifyAnchorFloatsInstruction(instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array): AnchorFloatsInstruction {
    const data = 'data' in instruction ? instruction.data : instruction;
    if (containsBytes(data, getU8Encoder().encode(0), 0)) { return AnchorFloatsInstruction.Create; }
if (containsBytes(data, getU8Encoder().encode(1), 0)) { return AnchorFloatsInstruction.Update; }
    throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION, { instructionData: data, programName: "anchorFloats" });
}

export type ParsedAnchorFloatsInstruction<TProgram extends string = 'Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS'> =
| { instructionType: AnchorFloatsInstruction.Create } & ParsedCreateInstruction<TProgram>
| { instructionType: AnchorFloatsInstruction.Update } & ParsedUpdateInstruction<TProgram>


        export function parseAnchorFloatsInstruction<TProgram extends string>(
            instruction: Instruction<TProgram> 
                & InstructionWithData<ReadonlyUint8Array>
        ): ParsedAnchorFloatsInstruction<TProgram> {
            const instructionType = identifyAnchorFloatsInstruction(instruction);
            switch (instructionType) {
                case AnchorFloatsInstruction.Create: { assertIsInstructionWithAccounts(instruction);
return { instructionType: AnchorFloatsInstruction.Create, ...parseCreateInstruction(instruction) }; }
case AnchorFloatsInstruction.Update: { assertIsInstructionWithAccounts(instruction);
return { instructionType: AnchorFloatsInstruction.Update, ...parseUpdateInstruction(instruction) }; }
                default: throw new SolanaError(SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE, { instructionType: instructionType as string, programName: "anchorFloats" });
            }
        }

export type AnchorFloatsPlugin = { accounts: AnchorFloatsPluginAccounts; instructions: AnchorFloatsPluginInstructions; }

export type AnchorFloatsPluginAccounts = { floatDataAccount: ReturnType<typeof getFloatDataAccountCodec> & SelfFetchFunctions<FloatDataAccountArgs, FloatDataAccount>; }

export type AnchorFloatsPluginInstructions = { create: (input: CreateInput) => ReturnType<typeof getCreateInstruction> & SelfPlanAndSendFunctions; update: (input: UpdateInput) => ReturnType<typeof getUpdateInstruction> & SelfPlanAndSendFunctions; }

export type AnchorFloatsPluginRequirements = ClientWithRpc<GetAccountInfoApi & GetMultipleAccountsApi> & ClientWithTransactionPlanning & ClientWithTransactionSending

export function anchorFloatsProgram() {
    return <T extends AnchorFloatsPluginRequirements>(client: T) => {
        return { ...client, anchorFloats: <AnchorFloatsPlugin>{ accounts: { floatDataAccount: addSelfFetchFunctions(client, getFloatDataAccountCodec()) }, instructions: { create: input => addSelfPlanAndSendFunctions(client, getCreateInstruction(input)), update: input => addSelfPlanAndSendFunctions(client, getUpdateInstruction(input)) } } };
    };
}