/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
	type Address,
	assertIsInstructionWithAccounts,
	type ClientWithTransactionPlanning,
	type ClientWithTransactionSending,
	containsBytes,
	getU8Encoder,
	type Instruction,
	type InstructionWithData,
	type ReadonlyUint8Array,
	SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
	SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
	SolanaError,
} from "@solana/kit";
import {
	addSelfPlanAndSendFunctions,
	type SelfPlanAndSendFunctions,
} from "@solana/program-client-core";
import {
	type CpiTransferInput,
	type DirectTransferInput,
	getCpiTransferInstruction,
	getDirectTransferInstruction,
	parseCpiTransferInstruction,
	type ParsedCpiTransferInstruction,
	type ParsedDirectTransferInstruction,
	parseDirectTransferInstruction,
} from "../instructions";

export const TRANSFER_SOL_PROGRAM_ADDRESS =
	"BuXKn8EiVMKF8zYThuea3xhLq3jUHTTwDDLfCoehq7WG" as Address<
		"BuXKn8EiVMKF8zYThuea3xhLq3jUHTTwDDLfCoehq7WG"
	>;

export enum TransferSolInstruction {
	CpiTransfer,
	DirectTransfer,
}

export function identifyTransferSolInstruction(
	instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array,
): TransferSolInstruction {
	const data = "data" in instruction ? instruction.data : instruction;
	if (containsBytes(data, getU8Encoder().encode(0), 0)) {
		return TransferSolInstruction.CpiTransfer;
	}
	if (containsBytes(data, getU8Encoder().encode(1), 0)) {
		return TransferSolInstruction.DirectTransfer;
	}
	throw new SolanaError(
		SOLANA_ERROR__PROGRAM_CLIENTS__FAILED_TO_IDENTIFY_INSTRUCTION,
		{ instructionData: data, programName: "transferSol" },
	);
}

export type ParsedTransferSolInstruction<
	TProgram extends string = "BuXKn8EiVMKF8zYThuea3xhLq3jUHTTwDDLfCoehq7WG",
> =
	| { instructionType: TransferSolInstruction.CpiTransfer }
		& ParsedCpiTransferInstruction<TProgram>
	| { instructionType: TransferSolInstruction.DirectTransfer }
		& ParsedDirectTransferInstruction<TProgram>;

export function parseTransferSolInstruction<TProgram extends string>(
	instruction:
		& Instruction<TProgram>
		& InstructionWithData<ReadonlyUint8Array>,
): ParsedTransferSolInstruction<TProgram> {
	const instructionType = identifyTransferSolInstruction(instruction);
	switch (instructionType) {
		case TransferSolInstruction.CpiTransfer: {
			assertIsInstructionWithAccounts(instruction);
			return {
				instructionType: TransferSolInstruction.CpiTransfer,
				...parseCpiTransferInstruction(instruction),
			};
		}
		case TransferSolInstruction.DirectTransfer: {
			assertIsInstructionWithAccounts(instruction);
			return {
				instructionType: TransferSolInstruction.DirectTransfer,
				...parseDirectTransferInstruction(instruction),
			};
		}
		default:
			throw new SolanaError(
				SOLANA_ERROR__PROGRAM_CLIENTS__UNRECOGNIZED_INSTRUCTION_TYPE,
				{
					instructionType: instructionType as string,
					programName: "transferSol",
				},
			);
	}
}

export type TransferSolPlugin = { instructions: TransferSolPluginInstructions };

export type TransferSolPluginInstructions = {
	cpiTransfer: (
		input: CpiTransferInput,
	) => ReturnType<typeof getCpiTransferInstruction> & SelfPlanAndSendFunctions;
	directTransfer: (
		input: DirectTransferInput,
	) =>
		& ReturnType<typeof getDirectTransferInstruction>
		& SelfPlanAndSendFunctions;
};

export type TransferSolPluginRequirements =
	& ClientWithTransactionPlanning
	& ClientWithTransactionSending;

export function transferSolProgram() {
	return <T extends TransferSolPluginRequirements>(client: T) => {
		return {
			...client,
			transferSol: <TransferSolPlugin> {
				instructions: {
					cpiTransfer: (input) =>
						addSelfPlanAndSendFunctions(
							client,
							getCpiTransferInstruction(input),
						),
					directTransfer: (input) =>
						addSelfPlanAndSendFunctions(
							client,
							getDirectTransferInstruction(input),
						),
				},
			},
		};
	};
}
