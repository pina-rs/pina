//! This code was AUTOGENERATED by `pina_codama_renderer`.
//! Please DO NOT EDIT THIS FILE directly.
//! Regenerate it from Codama IDLs instead.

use bytemuck::Pod;
use bytemuck::Zeroable;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Pod, Zeroable)]
pub struct FloatDataAccount {
	pub discriminator: u8,
	pub data_f64: pina_pod_primitives::PodU64,
	pub data_f32: pina_pod_primitives::PodU32,
	pub authority: solana_pubkey::Pubkey,
}

pub const FLOAT_DATA_ACCOUNT_DISCRIMINATOR: u8 = 1u8;

impl FloatDataAccount {
	pub const LEN: usize = core::mem::size_of::<Self>();

	pub const fn new(data_f64: pina_pod_primitives::PodU64, data_f32: pina_pod_primitives::PodU32, authority: solana_pubkey::Pubkey) -> Self {
		Self {
			discriminator: FLOAT_DATA_ACCOUNT_DISCRIMINATOR,
			data_f64,
			data_f32,
			authority,
		}
	}

	pub fn from_bytes(data: &[u8]) -> Result<&Self, solana_program_error::ProgramError> {
		let account = bytemuck::try_from_bytes::<Self>(data)
			.map_err(|_| solana_program_error::ProgramError::InvalidAccountData)?;
		if account.discriminator != FLOAT_DATA_ACCOUNT_DISCRIMINATOR {
			return Err(solana_program_error::ProgramError::InvalidAccountData);
		}
		Ok(account)
	}

	pub fn from_bytes_mut(data: &mut [u8]) -> Result<&mut Self, solana_program_error::ProgramError> {
		let account = bytemuck::try_from_bytes_mut::<Self>(data)
			.map_err(|_| solana_program_error::ProgramError::InvalidAccountData)?;
		if account.discriminator != FLOAT_DATA_ACCOUNT_DISCRIMINATOR {
			return Err(solana_program_error::ProgramError::InvalidAccountData);
		}
		Ok(account)
	}
}

impl<'a> TryFrom<&solana_account_info::AccountInfo<'a>> for FloatDataAccount {
	type Error = solana_program_error::ProgramError;

	fn try_from(account_info: &solana_account_info::AccountInfo<'a>) -> Result<Self, Self::Error> {
		let data_ref = (*account_info.data).borrow();
		let account = Self::from_bytes(&data_ref)?;
		Ok(*account)
	}
}
