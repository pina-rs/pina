//! This code was AUTOGENERATED by `pina_codama_renderer`.
//! Please DO NOT EDIT THIS FILE directly.
//! Regenerate it from Codama IDLs instead.

//! Shared Pina-compatible POD primitives used by generated clients.

use bytemuck::Pod;
use bytemuck::Zeroable;
use solana_program_error::ProgramError;

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodBool(pub u8);

impl PodBool {
	pub const fn from_bool(b: bool) -> Self {
		Self(if b { 1 } else { 0 })
	}
}

impl From<bool> for PodBool {
	fn from(value: bool) -> Self {
		Self::from_bool(value)
	}
}

impl From<PodBool> for bool {
	fn from(value: PodBool) -> Self {
		value.0 != 0
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodU16(pub [u8; 2]);
impl PodU16 {
	pub const fn from_primitive(n: u16) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<u16> for PodU16 {
	fn from(value: u16) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodU16> for u16 {
	fn from(value: PodU16) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodI16(pub [u8; 2]);
impl PodI16 {
	pub const fn from_primitive(n: i16) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<i16> for PodI16 {
	fn from(value: i16) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodI16> for i16 {
	fn from(value: PodI16) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodU32(pub [u8; 4]);
impl PodU32 {
	pub const fn from_primitive(n: u32) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<u32> for PodU32 {
	fn from(value: u32) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodU32> for u32 {
	fn from(value: PodU32) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodI32(pub [u8; 4]);
impl PodI32 {
	pub const fn from_primitive(n: i32) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<i32> for PodI32 {
	fn from(value: i32) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodI32> for i32 {
	fn from(value: PodI32) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodU64(pub [u8; 8]);
impl PodU64 {
	pub const fn from_primitive(n: u64) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<u64> for PodU64 {
	fn from(value: u64) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodU64> for u64 {
	fn from(value: PodU64) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodI64(pub [u8; 8]);
impl PodI64 {
	pub const fn from_primitive(n: i64) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<i64> for PodI64 {
	fn from(value: i64) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodI64> for i64 {
	fn from(value: PodI64) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodU128(pub [u8; 16]);
impl PodU128 {
	pub const fn from_primitive(n: u128) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<u128> for PodU128 {
	fn from(value: u128) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodU128> for u128 {
	fn from(value: PodU128) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodI128(pub [u8; 16]);
impl PodI128 {
	pub const fn from_primitive(n: i128) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<i128> for PodI128 {
	fn from(value: i128) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodI128> for i128 {
	fn from(value: PodI128) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[inline]
pub fn pod_from_bytes<T: Pod>(bytes: &[u8]) -> Result<&T, ProgramError> {
	bytemuck::try_from_bytes(bytes).map_err(|_| ProgramError::InvalidAccountData)
}

#[inline]
pub fn pod_from_bytes_mut<T: Pod>(bytes: &mut [u8]) -> Result<&mut T, ProgramError> {
	bytemuck::try_from_bytes_mut(bytes).map_err(|_| ProgramError::InvalidAccountData)
}

