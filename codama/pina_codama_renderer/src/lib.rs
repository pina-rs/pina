mod error;

use std::collections::BTreeMap;
use std::fs;
use std::path::Path;
use std::path::PathBuf;

use codama_nodes::AccountNode;
use codama_nodes::ConstantDiscriminatorNode;
use codama_nodes::CountNode;
use codama_nodes::DefinedTypeNode;
use codama_nodes::DiscriminatorNode;
use codama_nodes::Docs;
use codama_nodes::Endian;
use codama_nodes::HasKind;
use codama_nodes::InstructionAccountNode;
use codama_nodes::InstructionInputValueNode;
use codama_nodes::InstructionNode;
use codama_nodes::InstructionOptionalAccountStrategy;
use codama_nodes::IsAccountSigner;
use codama_nodes::NestedTypeNodeTrait;
use codama_nodes::Number;
use codama_nodes::NumberFormat;
use codama_nodes::NumberTypeNode;
use codama_nodes::PdaNode;
use codama_nodes::PdaSeedNode;
use codama_nodes::ProgramNode;
use codama_nodes::RootNode;
use codama_nodes::StructTypeNode;
use codama_nodes::TypeNode;
use codama_nodes::ValueNode;
pub use error::RenderError;
pub use error::Result;
use heck::ToShoutySnakeCase;
use heck::ToSnakeCase;
use heck::ToUpperCamelCase;

const GENERATED_HEADER: &str = r#"//! This code was AUTOGENERATED by `pina_codama_renderer`.
//! Please DO NOT EDIT THIS FILE directly.
//! Regenerate it from Codama IDLs instead.
"#;

const SHARED_RS: &str = r#"//! Shared Pina-compatible POD primitives used by generated clients.

use bytemuck::Pod;
use bytemuck::Zeroable;
use solana_program_error::ProgramError;

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodBool(pub u8);

impl PodBool {
	pub const fn from_bool(b: bool) -> Self {
		Self(if b { 1 } else { 0 })
	}
}

impl From<bool> for PodBool {
	fn from(value: bool) -> Self {
		Self::from_bool(value)
	}
}

impl From<PodBool> for bool {
	fn from(value: PodBool) -> Self {
		value.0 != 0
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodU16(pub [u8; 2]);
impl PodU16 {
	pub const fn from_primitive(n: u16) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<u16> for PodU16 {
	fn from(value: u16) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodU16> for u16 {
	fn from(value: PodU16) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodI16(pub [u8; 2]);
impl PodI16 {
	pub const fn from_primitive(n: i16) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<i16> for PodI16 {
	fn from(value: i16) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodI16> for i16 {
	fn from(value: PodI16) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodU32(pub [u8; 4]);
impl PodU32 {
	pub const fn from_primitive(n: u32) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<u32> for PodU32 {
	fn from(value: u32) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodU32> for u32 {
	fn from(value: PodU32) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodI32(pub [u8; 4]);
impl PodI32 {
	pub const fn from_primitive(n: i32) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<i32> for PodI32 {
	fn from(value: i32) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodI32> for i32 {
	fn from(value: PodI32) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodU64(pub [u8; 8]);
impl PodU64 {
	pub const fn from_primitive(n: u64) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<u64> for PodU64 {
	fn from(value: u64) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodU64> for u64 {
	fn from(value: PodU64) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodI64(pub [u8; 8]);
impl PodI64 {
	pub const fn from_primitive(n: i64) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<i64> for PodI64 {
	fn from(value: i64) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodI64> for i64 {
	fn from(value: PodI64) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodU128(pub [u8; 16]);
impl PodU128 {
	pub const fn from_primitive(n: u128) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<u128> for PodU128 {
	fn from(value: u128) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodU128> for u128 {
	fn from(value: PodU128) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Pod, Zeroable)]
#[repr(transparent)]
pub struct PodI128(pub [u8; 16]);
impl PodI128 {
	pub const fn from_primitive(n: i128) -> Self {
		Self(n.to_le_bytes())
	}
}
impl From<i128> for PodI128 {
	fn from(value: i128) -> Self {
		Self::from_primitive(value)
	}
}
impl From<PodI128> for i128 {
	fn from(value: PodI128) -> Self {
		Self::from_le_bytes(value.0)
	}
}

#[inline]
pub fn pod_from_bytes<T: Pod>(bytes: &[u8]) -> Result<&T, ProgramError> {
	bytemuck::try_from_bytes(bytes).map_err(|_| ProgramError::InvalidAccountData)
}

#[inline]
pub fn pod_from_bytes_mut<T: Pod>(bytes: &mut [u8]) -> Result<&mut T, ProgramError> {
	bytemuck::try_from_bytes_mut(bytes).map_err(|_| ProgramError::InvalidAccountData)
}
"#;

#[derive(Clone, Debug)]
pub struct RenderConfig {
	pub delete_folder_before_rendering: bool,
	pub generated_folder: PathBuf,
}

impl Default for RenderConfig {
	fn default() -> Self {
		Self {
			delete_folder_before_rendering: true,
			generated_folder: PathBuf::from("src/generated"),
		}
	}
}

#[derive(Clone, Debug)]
struct DiscriminatorInfo {
	const_name: String,
	const_type: String,
	const_value: String,
}

pub fn read_root_node(path: &Path) -> Result<RootNode> {
	let idl = fs::read_to_string(path).map_err(|source| {
		RenderError::ReadFile {
			path: path.to_path_buf(),
			source,
		}
	})?;
	serde_json::from_str(&idl).map_err(|source| {
		RenderError::ParseIdl {
			path: path.to_path_buf(),
			source,
		}
	})
}

pub fn render_idl_file(path: &Path, crate_dir: &Path, config: &RenderConfig) -> Result<()> {
	let root = read_root_node(path)?;
	render_root_node(&root, crate_dir, config)
}

pub fn render_root_node(root: &RootNode, crate_dir: &Path, config: &RenderConfig) -> Result<()> {
	ensure_crate_scaffold(crate_dir, root.program.name.as_ref())?;
	let generated_dir = crate_dir.join(&config.generated_folder);

	if config.delete_folder_before_rendering && generated_dir.exists() {
		fs::remove_dir_all(&generated_dir).map_err(|source| {
			RenderError::WriteFile {
				path: generated_dir.clone(),
				source,
			}
		})?;
	}

	let files = render_program_to_files(root)?;
	write_files(&generated_dir, files)
}

pub fn render_program(
	program: &ProgramNode,
	crate_dir: &Path,
	config: &RenderConfig,
) -> Result<()> {
	let root = RootNode::new(program.clone());
	render_root_node(&root, crate_dir, config)
}

fn render_program_to_files(root: &RootNode) -> Result<BTreeMap<PathBuf, String>> {
	let program = &root.program;
	let mut files = BTreeMap::new();

	let program_constants = std::iter::once(&root.program)
		.chain(root.additional_programs.iter())
		.collect::<Vec<_>>();
	let primary_program_const = program_id_const_name(program.name.as_ref());

	let pdas_by_name = program
		.pdas
		.iter()
		.map(|pda| (pda.name.as_ref().to_string(), pda))
		.collect::<BTreeMap<_, _>>();

	files.insert(PathBuf::from("mod.rs"), page(&render_root_mod(program)));
	files.insert(
		PathBuf::from("programs.rs"),
		page(&render_programs_mod(&program_constants)),
	);
	files.insert(PathBuf::from("shared.rs"), page(SHARED_RS));

	if !program.accounts.is_empty() {
		files.insert(
			PathBuf::from("accounts/mod.rs"),
			page(&render_accounts_mod(&program.accounts)),
		);

		for account in &program.accounts {
			let filename = format!("accounts/{}.rs", snake(account.name.as_ref()));
			let account_content = render_account_page(
				account,
				&primary_program_const,
				pdas_by_name
					.get(account.pda.as_ref().map_or("", |p| p.name.as_ref()))
					.copied(),
			)?;
			files.insert(PathBuf::from(filename), page(&account_content));
		}
	}

	if !program.instructions.is_empty() {
		files.insert(
			PathBuf::from("instructions/mod.rs"),
			page(&render_instructions_mod(&program.instructions)),
		);
		for instruction in &program.instructions {
			let filename = format!("instructions/{}.rs", snake(instruction.name.as_ref()));
			let instruction_content =
				render_instruction_page(instruction, program, &primary_program_const)?;
			files.insert(PathBuf::from(filename), page(&instruction_content));
		}
	}

	if !program.defined_types.is_empty() {
		files.insert(
			PathBuf::from("types/mod.rs"),
			page(&render_defined_types_mod(&program.defined_types)),
		);
		for defined_type in &program.defined_types {
			let filename = format!("types/{}.rs", snake(defined_type.name.as_ref()));
			let defined_type_content = render_defined_type_page(defined_type)?;
			files.insert(PathBuf::from(filename), page(&defined_type_content));
		}
	}

	if !program.errors.is_empty() {
		files.insert(
			PathBuf::from("errors/mod.rs"),
			page(&render_errors_mod(program)),
		);
		files.insert(
			PathBuf::from(format!("errors/{}.rs", snake(program.name.as_ref()))),
			page(&render_errors_page(program)),
		);
	}

	Ok(files)
}

fn ensure_crate_scaffold(crate_dir: &Path, program_name: &str) -> Result<()> {
	fs::create_dir_all(crate_dir.join("src")).map_err(|source| {
		RenderError::WriteFile {
			path: crate_dir.to_path_buf(),
			source,
		}
	})?;

	let lib_rs_path = crate_dir.join("src/lib.rs");
	if !lib_rs_path.exists() {
		fs::write(&lib_rs_path, "pub mod generated;\npub use generated::*;\n").map_err(
			|source| {
				RenderError::WriteFile {
					path: lib_rs_path.clone(),
					source,
				}
			},
		)?;
	}

	let cargo_toml_path = crate_dir.join("Cargo.toml");
	if !cargo_toml_path.exists() {
		let package_name = format!("{}-client", snake(program_name).replace('_', "-"));
		let cargo_toml = format!(
			r#"[package]
name = "{package_name}"
version = "0.0.0"
edition = "2021"
publish = false

[dependencies]
bytemuck = {{ workspace = true }}
num-derive = {{ workspace = true }}
num-traits = {{ workspace = true }}
solana-account-info = {{ workspace = true }}
solana-cpi = {{ workspace = true }}
solana-instruction = {{ workspace = true }}
solana-program-error = {{ workspace = true }}
solana-pubkey = {{ workspace = true }}
thiserror = {{ workspace = true }}
"#
		);
		fs::write(&cargo_toml_path, cargo_toml).map_err(|source| {
			RenderError::WriteFile {
				path: cargo_toml_path.clone(),
				source,
			}
		})?;
	}

	Ok(())
}

fn write_files(base: &Path, files: BTreeMap<PathBuf, String>) -> Result<()> {
	for (relative_path, content) in files {
		let file_path = base.join(relative_path);
		if let Some(parent) = file_path.parent() {
			fs::create_dir_all(parent).map_err(|source| {
				RenderError::WriteFile {
					path: parent.to_path_buf(),
					source,
				}
			})?;
		}
		fs::write(&file_path, content).map_err(|source| {
			RenderError::WriteFile {
				path: file_path.clone(),
				source,
			}
		})?;
	}
	Ok(())
}

fn render_root_mod(program: &ProgramNode) -> String {
	let mut lines = Vec::new();

	if !program.accounts.is_empty() {
		lines.push("pub mod accounts;".to_string());
	}
	if !program.errors.is_empty() {
		lines.push("pub mod errors;".to_string());
	}
	if !program.instructions.is_empty() {
		lines.push("pub mod instructions;".to_string());
	}
	lines.push("pub mod programs;".to_string());
	lines.push("pub mod shared;".to_string());
	if !program.defined_types.is_empty() {
		lines.push("pub mod types;".to_string());
	}
	lines.push(String::new());
	lines.push("pub(crate) use programs::*;".to_string());

	lines.join("\n")
}

fn render_programs_mod(programs: &[&ProgramNode]) -> String {
	let mut lines = Vec::new();
	lines.push("use solana_pubkey::{pubkey, Pubkey};".to_string());
	lines.push(String::new());

	for program in programs {
		lines.push(format!(
			"pub const {}: Pubkey = pubkey!(\"{}\");",
			program_id_const_name(program.name.as_ref()),
			program.public_key
		));
	}

	lines.join("\n")
}

fn render_accounts_mod(accounts: &[AccountNode]) -> String {
	let mut lines = Vec::new();
	for account in accounts {
		lines.push(format!(
			"pub(crate) mod r#{};",
			snake(account.name.as_ref())
		));
	}
	lines.push(String::new());
	for account in accounts {
		lines.push(format!(
			"pub use self::r#{}::*;",
			snake(account.name.as_ref())
		));
	}
	lines.join("\n")
}

fn render_instructions_mod(instructions: &[InstructionNode]) -> String {
	let mut lines = Vec::new();
	for instruction in instructions {
		lines.push(format!(
			"pub(crate) mod r#{};",
			snake(instruction.name.as_ref())
		));
	}
	lines.push(String::new());
	for instruction in instructions {
		lines.push(format!(
			"pub use self::r#{}::*;",
			snake(instruction.name.as_ref())
		));
	}
	lines.join("\n")
}

fn render_defined_types_mod(defined_types: &[DefinedTypeNode]) -> String {
	let mut lines = Vec::new();
	for defined_type in defined_types {
		lines.push(format!(
			"pub(crate) mod r#{};",
			snake(defined_type.name.as_ref())
		));
	}
	lines.push(String::new());
	for defined_type in defined_types {
		lines.push(format!(
			"pub use self::r#{}::*;",
			snake(defined_type.name.as_ref())
		));
	}
	lines.join("\n")
}

fn render_errors_mod(program: &ProgramNode) -> String {
	let mut lines = Vec::new();
	lines.push(format!("pub(crate) mod {};", snake(program.name.as_ref())));
	lines.push(format!(
		"pub use self::{}::{}Error;",
		snake(program.name.as_ref()),
		pascal(program.name.as_ref())
	));
	lines.join("\n")
}

fn render_errors_page(program: &ProgramNode) -> String {
	let mut lines = Vec::new();
	lines.push("use num_derive::FromPrimitive;".to_string());
	lines.push("use thiserror::Error;".to_string());
	lines.push(String::new());
	lines.push("#[derive(Clone, Debug, Eq, Error, FromPrimitive, PartialEq)]".to_string());
	lines.push(format!(
		"pub enum {}Error {{",
		pascal(program.name.as_ref())
	));
	for error in &program.errors {
		for doc_line in render_docs(&error.docs, 1) {
			lines.push(doc_line);
		}
		lines.push(format!("\t/// {} - {}", error.code, error.message));
		lines.push(format!(
			"\t#[error(\"{}\")]",
			escape_rust_str(&error.message)
		));
		lines.push(format!(
			"\t{} = 0x{:X},",
			pascal(error.name.as_ref()),
			error.code
		));
	}
	lines.push("}".to_string());
	lines.push(String::new());
	lines.push(format!(
		"impl From<{}Error> for solana_program_error::ProgramError {{",
		pascal(program.name.as_ref())
	));
	lines.push(format!(
		"\tfn from(value: {}Error) -> Self {{",
		pascal(program.name.as_ref())
	));
	lines.push("\t\tsolana_program_error::ProgramError::Custom(value as u32)".to_string());
	lines.push("\t}".to_string());
	lines.push("}".to_string());

	lines.join("\n")
}

fn render_account_page(
	account: &AccountNode,
	primary_program_const: &str,
	pda: Option<&PdaNode>,
) -> Result<String> {
	let account_name = pascal(account.name.as_ref());
	let context = format!("account `{account_name}`");
	let discriminator =
		render_constant_discriminator(account.name.as_ref(), &account.discriminators, &context)?;

	let data_type: &StructTypeNode = account.data.get_nested_type_node();
	let mut field_lines = Vec::new();
	let mut ctor_args = Vec::new();
	let mut ctor_inits = Vec::new();

	for doc_line in render_docs(&account.docs, 0) {
		field_lines.push(doc_line);
	}

	if let Some(discriminator) = &discriminator {
		field_lines.push(format!(
			"\tpub discriminator: {},",
			discriminator.const_type
		));
	}

	for field in &data_type.fields {
		let field_name = snake(field.name.as_ref());
		let field_context = format!("{}.{}", account_name, field_name);
		let field_type = render_type_for_pod(&field.r#type, &field_context)?;
		for doc_line in render_docs(&field.docs, 1) {
			field_lines.push(doc_line);
		}
		field_lines.push(format!("\tpub {field_name}: {field_type},"));
		ctor_args.push(format!("{field_name}: {field_type}"));
		ctor_inits.push(format!("\t\t\t{field_name},"));
	}

	let mut lines = Vec::new();
	lines.push("use bytemuck::Pod;".to_string());
	lines.push("use bytemuck::Zeroable;".to_string());
	lines.push(String::new());
	lines.push("#[repr(C)]".to_string());
	lines.push("#[derive(Clone, Copy, Debug, PartialEq, Eq, Pod, Zeroable)]".to_string());
	lines.push(format!("pub struct {account_name} {{"));
	lines.extend(field_lines);
	lines.push("}".to_string());
	lines.push(String::new());

	if let Some(discriminator) = &discriminator {
		lines.push(format!(
			"pub const {}: {} = {};",
			discriminator.const_name, discriminator.const_type, discriminator.const_value
		));
		lines.push(String::new());
	}

	lines.push(format!("impl {account_name} {{"));
	lines.push("\tpub const LEN: usize = core::mem::size_of::<Self>();".to_string());
	lines.push(String::new());

	if ctor_args.is_empty() {
		lines.push("\tpub const fn new() -> Self {".to_string());
		lines.push("\t\tSelf {".to_string());
		if let Some(discriminator) = &discriminator {
			lines.push(format!(
				"\t\t\tdiscriminator: {},",
				discriminator.const_name
			));
		}
		lines.push("\t\t}".to_string());
		lines.push("\t}".to_string());
	} else {
		lines.push(format!(
			"\tpub const fn new({}) -> Self {{",
			ctor_args.join(", ")
		));
		lines.push("\t\tSelf {".to_string());
		if let Some(discriminator) = &discriminator {
			lines.push(format!(
				"\t\t\tdiscriminator: {},",
				discriminator.const_name
			));
		}
		lines.extend(ctor_inits);
		lines.push("\t\t}".to_string());
		lines.push("\t}".to_string());
	}

	lines.push(String::new());
	lines.push(
		"\tpub fn from_bytes(data: &[u8]) -> Result<&Self, solana_program_error::ProgramError> {"
			.to_string(),
	);
	lines.push(
		"\t\tlet account = crate::generated::shared::pod_from_bytes::<Self>(data)?;".to_string(),
	);
	if let Some(discriminator) = &discriminator {
		lines.push(format!(
			"\t\tif account.discriminator != {} {{",
			discriminator.const_name
		));
		lines.push(
			"\t\t\treturn Err(solana_program_error::ProgramError::InvalidAccountData);".to_string(),
		);
		lines.push("\t\t}".to_string());
	}
	lines.push("\t\tOk(account)".to_string());
	lines.push("\t}".to_string());
	lines.push(String::new());
	lines.push(
		"\tpub fn from_bytes_mut(data: &mut [u8]) -> Result<&mut Self, \
		 solana_program_error::ProgramError> {"
			.to_string(),
	);
	lines.push(
		"\t\tlet account = crate::generated::shared::pod_from_bytes_mut::<Self>(data)?;"
			.to_string(),
	);
	if let Some(discriminator) = &discriminator {
		lines.push(format!(
			"\t\tif account.discriminator != {} {{",
			discriminator.const_name
		));
		lines.push(
			"\t\t\treturn Err(solana_program_error::ProgramError::InvalidAccountData);".to_string(),
		);
		lines.push("\t\t}".to_string());
	}
	lines.push("\t\tOk(account)".to_string());
	lines.push("\t}".to_string());
	lines.push("}".to_string());
	lines.push(String::new());
	lines.push(format!(
		"impl<'a> TryFrom<&solana_account_info::AccountInfo<'a>> for {account_name} {{"
	));
	lines.push("\ttype Error = solana_program_error::ProgramError;".to_string());
	lines.push(String::new());
	lines.push(
		"\tfn try_from(account_info: &solana_account_info::AccountInfo<'a>) -> Result<Self, \
		 Self::Error> {"
			.to_string(),
	);
	lines.push("\t\tlet data_ref = (*account_info.data).borrow();".to_string());
	lines.push("\t\tlet account = Self::from_bytes(&data_ref)?;".to_string());
	lines.push("\t\tOk(*account)".to_string());
	lines.push("\t}".to_string());
	lines.push("}".to_string());

	if let Some(pda) = pda {
		lines.push(String::new());
		lines.extend(render_account_pda_helpers(
			account_name.as_str(),
			pda,
			primary_program_const,
		)?);
	}

	Ok(lines.join("\n"))
}

fn render_account_pda_helpers(
	account_name: &str,
	pda: &PdaNode,
	primary_program_const: &str,
) -> Result<Vec<String>> {
	let mut params = Vec::new();
	let mut seed_exprs = Vec::new();

	for seed in &pda.seeds {
		match seed {
			PdaSeedNode::Variable(variable) => {
				let seed_name = snake(variable.name.as_ref());
				let context = format!("PDA `{}` variable seed `{seed_name}`", pda.name.as_ref());
				let (param_type, seed_expr) =
					render_variable_seed_parameter(&seed_name, &variable.r#type, &context)?;
				params.push(format!("{seed_name}: {param_type}"));
				seed_exprs.push(seed_expr);
			}
			PdaSeedNode::Constant(constant) => {
				let context = format!("PDA `{}` constant seed", pda.name.as_ref());
				seed_exprs.push(render_constant_seed_expression(
					&constant.r#type,
					&constant.value,
					&context,
					primary_program_const,
				)?);
			}
		}
	}

	let mut lines = Vec::new();
	lines.push(format!("impl {account_name} {{"));
	lines.push(format!(
		"\tpub fn find_pda({}) -> (solana_pubkey::Pubkey, u8) {{",
		params.join(", ")
	));
	lines.push("\t\tsolana_pubkey::Pubkey::find_program_address(".to_string());
	lines.push("\t\t\t&[".to_string());
	for seed_expr in &seed_exprs {
		lines.push(format!("\t\t\t\t{seed_expr},"));
	}
	lines.push("\t\t\t],".to_string());
	lines.push(format!("\t\t\t&crate::{primary_program_const},"));
	lines.push("\t\t)".to_string());
	lines.push("\t}".to_string());
	lines.push(String::new());

	let mut create_params = params.clone();
	create_params.push("bump: u8".to_string());
	lines.push(format!(
		"\tpub fn create_pda({}) -> Result<solana_pubkey::Pubkey, solana_pubkey::PubkeyError> {{",
		create_params.join(", ")
	));
	lines.push("\t\tsolana_pubkey::Pubkey::create_program_address(".to_string());
	lines.push("\t\t\t&[".to_string());
	for seed_expr in &seed_exprs {
		lines.push(format!("\t\t\t\t{seed_expr},"));
	}
	lines.push("\t\t\t\t&[bump],".to_string());
	lines.push("\t\t\t],".to_string());
	lines.push(format!("\t\t\t&crate::{primary_program_const},"));
	lines.push("\t\t)".to_string());
	lines.push("\t}".to_string());
	lines.push("}".to_string());

	Ok(lines)
}

fn render_instruction_page(
	instruction: &InstructionNode,
	program: &ProgramNode,
	primary_program_const: &str,
) -> Result<String> {
	let instruction_name = pascal(instruction.name.as_ref());
	let context = format!("instruction `{instruction_name}`");
	let discriminator = render_constant_discriminator(
		instruction.name.as_ref(),
		&instruction.discriminators,
		&context,
	)?;
	let discriminator = discriminator.ok_or_else(|| {
		RenderError::MissingDiscriminator {
			context: context.clone(),
		}
	})?;

	let mut lines = Vec::new();
	lines.push(format!(
		"pub const {}: {} = {};",
		discriminator.const_name, discriminator.const_type, discriminator.const_value
	));
	lines.push(String::new());
	lines.push("/// Accounts.".to_string());
	lines.push("#[derive(Clone, Debug)]".to_string());
	lines.push(format!("pub struct {instruction_name} {{"));
	for account in &instruction.accounts {
		let (field_type, _) = render_instruction_account_field_type(account);
		for doc_line in render_docs(&account.docs, 1) {
			lines.push(doc_line);
		}
		lines.push(format!(
			"\tpub {}: {},",
			snake(account.name.as_ref()),
			field_type
		));
	}
	lines.push("}".to_string());
	lines.push(String::new());

	let mut new_params = Vec::new();
	let mut new_inits = Vec::new();
	for account in &instruction.accounts {
		let field_name = snake(account.name.as_ref());
		let (field_type, base_type) = render_instruction_account_field_type(account);
		let default_value = render_instruction_account_default_value(
			account,
			base_type,
			primary_program_const,
			program,
		)?;
		match default_value {
			Some(default_expr) => {
				new_inits.push(format!("\t\t\t{field_name}: {default_expr},"));
			}
			None => {
				new_params.push(format!("{field_name}: {field_type}"));
				new_inits.push(format!("\t\t\t{field_name},"));
			}
		}
	}
	lines.push(format!("impl {instruction_name} {{"));
	lines.push(format!(
		"\tpub fn new({}) -> Self {{",
		new_params.join(", ")
	));
	lines.push("\t\tSelf {".to_string());
	lines.extend(new_inits);
	lines.push("\t\t}".to_string());
	lines.push("\t}".to_string());
	lines.push(String::new());
	lines.push(format!(
		"\tpub fn instruction(&self, data: {}InstructionData) -> solana_instruction::Instruction \
		 {{",
		instruction_name
	));
	lines.push("\t\tself.instruction_with_remaining_accounts(data, &[])".to_string());
	lines.push("\t}".to_string());
	lines.push(String::new());
	lines.push("\t#[allow(clippy::arithmetic_side_effects)]".to_string());
	lines.push("\tpub fn instruction_with_remaining_accounts(".to_string());
	lines.push("\t\t&self,".to_string());
	lines.push(format!("\t\tdata: {}InstructionData,", instruction_name));
	lines.push("\t\tremaining_accounts: &[solana_instruction::AccountMeta],".to_string());
	lines.push("\t) -> solana_instruction::Instruction {".to_string());
	lines.push(format!(
		"\t\tlet mut accounts = Vec::with_capacity({} + remaining_accounts.len());",
		instruction.accounts.len()
	));
	lines.extend(render_instruction_account_metas(
		instruction,
		primary_program_const,
	));
	lines.push("\t\taccounts.extend_from_slice(remaining_accounts);".to_string());
	lines.push("\t\tlet data = bytemuck::bytes_of(&data).to_vec();".to_string());
	lines.push(String::new());
	lines.push("\t\tsolana_instruction::Instruction {".to_string());
	lines.push(format!("\t\t\tprogram_id: crate::{primary_program_const},"));
	lines.push("\t\t\taccounts,".to_string());
	lines.push("\t\t\tdata,".to_string());
	lines.push("\t\t}".to_string());
	lines.push("\t}".to_string());
	lines.push("}".to_string());
	lines.push(String::new());

	let mut data_fields = Vec::new();
	data_fields.push(format!(
		"\tpub discriminator: {},",
		discriminator.const_type
	));
	let mut data_new_args = Vec::new();
	let mut data_inits = Vec::new();
	data_inits.push(format!(
		"\t\t\tdiscriminator: {},",
		discriminator.const_name
	));

	for argument in &instruction.arguments {
		let argument_name = snake(argument.name.as_ref());
		let field_context = format!("{instruction_name}.{}", argument_name);
		let argument_type = render_type_for_pod(&argument.r#type, &field_context)?;
		for doc_line in render_docs(&argument.docs, 1) {
			data_fields.push(doc_line);
		}
		data_fields.push(format!("\tpub {argument_name}: {argument_type},"));
		data_new_args.push(format!("{argument_name}: {argument_type}"));
		data_inits.push(format!("\t\t\t{argument_name},"));
	}

	lines.push("#[repr(C)]".to_string());
	lines.push(
		"#[derive(Clone, Copy, Debug, PartialEq, Eq, bytemuck::Pod, bytemuck::Zeroable)]"
			.to_string(),
	);
	lines.push(format!("pub struct {}InstructionData {{", instruction_name));
	lines.extend(data_fields);
	lines.push("}".to_string());
	lines.push(String::new());
	lines.push(format!("impl {}InstructionData {{", instruction_name));
	lines.push(format!(
		"\tpub const fn new({}) -> Self {{",
		data_new_args.join(", ")
	));
	lines.push("\t\tSelf {".to_string());
	lines.extend(data_inits);
	lines.push("\t\t}".to_string());
	lines.push("\t}".to_string());
	lines.push("}".to_string());

	Ok(lines.join("\n"))
}

fn render_instruction_account_metas(
	instruction: &InstructionNode,
	primary_program_const: &str,
) -> Vec<String> {
	let mut lines = Vec::new();
	for account in &instruction.accounts {
		let field_name = snake(account.name.as_ref());
		let meta_ctor = if account.is_writable {
			"solana_instruction::AccountMeta::new"
		} else {
			"solana_instruction::AccountMeta::new_readonly"
		};

		let signer_expr = match account.is_signer {
			IsAccountSigner::False => "false".to_string(),
			IsAccountSigner::True => "true".to_string(),
			IsAccountSigner::Either => format!("self.{field_name}.1"),
		};
		let key_expr = match account.is_signer {
			IsAccountSigner::Either => format!("self.{field_name}.0"),
			_ => format!("self.{field_name}"),
		};

		if account.is_optional {
			match account.is_signer {
				IsAccountSigner::Either => {
					lines.push(format!(
						"\t\tif let Some(({field_name}, signer)) = self.{field_name} {{"
					));
					lines.push(format!(
						"\t\t\taccounts.push({meta_ctor}({field_name}, signer));"
					));
					lines.push("\t\t}".to_string());
				}
				_ => {
					lines.push(format!(
						"\t\tif let Some({field_name}) = self.{field_name} {{"
					));
					lines.push(format!(
						"\t\t\taccounts.push({meta_ctor}({field_name}, {signer_expr}));"
					));
					lines.push("\t\t}".to_string());
				}
			}

			if matches!(
				instruction.optional_account_strategy,
				InstructionOptionalAccountStrategy::ProgramId
			) {
				lines.push(format!("\t\telse {{"));
				lines.push(format!(
					"\t\t\taccounts.\
					 push(solana_instruction::AccountMeta::new_readonly(crate::{primary_program_const}, \
					 false));"
				));
				lines.push("\t\t}".to_string());
			}
			continue;
		}

		lines.push(format!(
			"\t\taccounts.push({meta_ctor}({}, {}));",
			key_expr, signer_expr
		));
	}
	lines
}

fn render_instruction_account_field_type(account: &InstructionAccountNode) -> (String, String) {
	let base_type = match account.is_signer {
		IsAccountSigner::Either => "(solana_pubkey::Pubkey, bool)".to_string(),
		IsAccountSigner::False | IsAccountSigner::True => "solana_pubkey::Pubkey".to_string(),
	};
	if account.is_optional {
		(format!("Option<{base_type}>"), base_type)
	} else {
		(base_type.clone(), base_type)
	}
}

fn render_instruction_account_default_value(
	account: &InstructionAccountNode,
	base_type: String,
	primary_program_const: &str,
	program: &ProgramNode,
) -> Result<Option<String>> {
	if account.is_optional {
		return Ok(Some("None".to_string()));
	}

	let Some(default_value) = &account.default_value else {
		return Ok(None);
	};

	let value = match default_value {
		InstructionInputValueNode::PublicKey(public_key) => {
			format!("solana_pubkey::pubkey!(\"{}\")", public_key.public_key)
		}
		InstructionInputValueNode::ProgramId(_) => format!("crate::{primary_program_const}"),
		InstructionInputValueNode::ProgramLink(program_link) => {
			format!(
				"crate::{}",
				program_id_const_name(program_link.name.as_ref())
			)
		}
		_ => {
			return Err(RenderError::UnsupportedValue {
				context: format!(
					"instruction `{}` account `{}` default value",
					pascal(program.name.as_ref()),
					snake(account.name.as_ref())
				),
				kind: default_value.kind(),
				reason: "only public key/program defaults are supported".to_string(),
			});
		}
	};

	if matches!(account.is_signer, IsAccountSigner::Either) {
		Ok(Some(format!("({value}, false)")))
	} else {
		let _ = base_type;
		Ok(Some(value))
	}
}

fn render_defined_type_page(defined_type: &DefinedTypeNode) -> Result<String> {
	let name = pascal(defined_type.name.as_ref());
	let context = format!("defined type `{name}`");
	match &defined_type.r#type {
		TypeNode::Struct(struct_type) => {
			render_defined_struct(name.as_str(), struct_type, &defined_type.docs)
		}
		TypeNode::Link(link) => {
			Ok(format!(
				"pub type {name} = crate::generated::types::{};",
				pascal(link.name.as_ref())
			))
		}
		other => {
			let ty = render_type_for_pod(other, &context)?;
			Ok(format!("pub type {name} = {ty};"))
		}
	}
}

fn render_defined_struct(name: &str, struct_type: &StructTypeNode, docs: &Docs) -> Result<String> {
	let mut lines = Vec::new();
	for doc_line in render_docs(docs, 0) {
		lines.push(doc_line);
	}
	lines.push("#[repr(C)]".to_string());
	lines.push(
		"#[derive(Clone, Copy, Debug, PartialEq, Eq, bytemuck::Pod, bytemuck::Zeroable)]"
			.to_string(),
	);
	lines.push(format!("pub struct {name} {{"));
	let mut ctor_args = Vec::new();
	let mut ctor_inits = Vec::new();
	for field in &struct_type.fields {
		let field_name = snake(field.name.as_ref());
		let field_context = format!("{name}.{}", field_name);
		let field_type = render_type_for_pod(&field.r#type, &field_context)?;
		for doc_line in render_docs(&field.docs, 1) {
			lines.push(doc_line);
		}
		lines.push(format!("\tpub {field_name}: {field_type},"));
		ctor_args.push(format!("{field_name}: {field_type}"));
		ctor_inits.push(format!("\t\t\t{field_name},"));
	}
	lines.push("}".to_string());
	lines.push(String::new());
	lines.push(format!("impl {name} {{"));
	lines.push(format!(
		"\tpub const fn new({}) -> Self {{",
		ctor_args.join(", ")
	));
	lines.push("\t\tSelf {".to_string());
	lines.extend(ctor_inits);
	lines.push("\t\t}".to_string());
	lines.push("\t}".to_string());
	lines.push("}".to_string());
	Ok(lines.join("\n"))
}

fn render_constant_discriminator(
	prefix: &str,
	discriminators: &[DiscriminatorNode],
	context: &str,
) -> Result<Option<DiscriminatorInfo>> {
	let Some(constant_discriminator) = discriminators.iter().find_map(|discriminator| {
		match discriminator {
			DiscriminatorNode::Constant(node) if node.offset == 0 => Some(node),
			_ => None,
		}
	}) else {
		return Ok(None);
	};

	let (const_type, const_value) =
		render_constant_discriminator_value(constant_discriminator, context)?;
	Ok(Some(DiscriminatorInfo {
		const_name: format!("{}_DISCRIMINATOR", shouty(prefix)),
		const_type,
		const_value,
	}))
}

fn render_constant_discriminator_value(
	discriminator: &ConstantDiscriminatorNode,
	context: &str,
) -> Result<(String, String)> {
	let number_type = match discriminator.constant.r#type.as_ref() {
		TypeNode::Number(number_type) => number_type,
		other => {
			return Err(RenderError::UnsupportedDiscriminator {
				context: context.to_string(),
				reason: format!("expected number type, found `{}`", other.kind()),
			});
		}
	};

	let number_value = match discriminator.constant.value.as_ref() {
		ValueNode::Number(number_value) => &number_value.number,
		other => {
			return Err(RenderError::UnsupportedDiscriminator {
				context: context.to_string(),
				reason: format!("expected numeric value, found `{}`", other.kind()),
			});
		}
	};

	let ty = render_discriminator_type(number_type, context)?;
	let value = render_discriminator_literal(number_type, number_value, context)?;
	Ok((ty, value))
}

fn render_discriminator_type(number_type: &NumberTypeNode, context: &str) -> Result<String> {
	if !matches!(number_type.endian, Endian::Little) {
		return Err(RenderError::UnsupportedDiscriminator {
			context: context.to_string(),
			reason: "only little-endian discriminators are supported".to_string(),
		});
	}

	match number_type.format {
		NumberFormat::U8 => Ok("u8".to_string()),
		NumberFormat::I8 => Ok("i8".to_string()),
		NumberFormat::U16 => Ok("crate::generated::shared::PodU16".to_string()),
		NumberFormat::I16 => Ok("crate::generated::shared::PodI16".to_string()),
		NumberFormat::U32 => Ok("crate::generated::shared::PodU32".to_string()),
		NumberFormat::I32 => Ok("crate::generated::shared::PodI32".to_string()),
		NumberFormat::U64 => Ok("crate::generated::shared::PodU64".to_string()),
		NumberFormat::I64 => Ok("crate::generated::shared::PodI64".to_string()),
		NumberFormat::U128 => Ok("crate::generated::shared::PodU128".to_string()),
		NumberFormat::I128 => Ok("crate::generated::shared::PodI128".to_string()),
		NumberFormat::F32 | NumberFormat::F64 | NumberFormat::ShortU16 => {
			Err(RenderError::UnsupportedDiscriminator {
				context: context.to_string(),
				reason: format!(
					"unsupported discriminator format `{:?}`",
					number_type.format
				),
			})
		}
	}
}

fn render_discriminator_literal(
	number_type: &NumberTypeNode,
	value: &Number,
	context: &str,
) -> Result<String> {
	let literal = match number_type.format {
		NumberFormat::U8 => format!("{}u8", cast_unsigned(value, u8::MAX as u128, context)?),
		NumberFormat::I8 => {
			format!(
				"{}i8",
				cast_signed(value, i8::MIN as i128, i8::MAX as i128, context)?
			)
		}
		NumberFormat::U16 => format!("{}u16", cast_unsigned(value, u16::MAX as u128, context)?),
		NumberFormat::I16 => {
			format!(
				"{}i16",
				cast_signed(value, i16::MIN as i128, i16::MAX as i128, context)?
			)
		}
		NumberFormat::U32 => format!("{}u32", cast_unsigned(value, u32::MAX as u128, context)?),
		NumberFormat::I32 => {
			format!(
				"{}i32",
				cast_signed(value, i32::MIN as i128, i32::MAX as i128, context)?
			)
		}
		NumberFormat::U64 => format!("{}u64", cast_unsigned(value, u64::MAX as u128, context)?),
		NumberFormat::I64 => {
			format!(
				"{}i64",
				cast_signed(value, i64::MIN as i128, i64::MAX as i128, context)?
			)
		}
		NumberFormat::U128 => format!("{}u128", cast_unsigned(value, u128::MAX, context)?),
		NumberFormat::I128 => {
			format!("{}i128", cast_signed(value, i128::MIN, i128::MAX, context)?)
		}
		NumberFormat::F32 | NumberFormat::F64 | NumberFormat::ShortU16 => {
			return Err(RenderError::UnsupportedDiscriminator {
				context: context.to_string(),
				reason: "float/shortU16 discriminators are unsupported".to_string(),
			});
		}
	};

	Ok(match number_type.format {
		NumberFormat::U8 | NumberFormat::I8 => literal,
		NumberFormat::U16 => format!("crate::generated::shared::PodU16::from({literal})"),
		NumberFormat::I16 => format!("crate::generated::shared::PodI16::from({literal})"),
		NumberFormat::U32 => format!("crate::generated::shared::PodU32::from({literal})"),
		NumberFormat::I32 => format!("crate::generated::shared::PodI32::from({literal})"),
		NumberFormat::U64 => format!("crate::generated::shared::PodU64::from({literal})"),
		NumberFormat::I64 => format!("crate::generated::shared::PodI64::from({literal})"),
		NumberFormat::U128 => format!("crate::generated::shared::PodU128::from({literal})"),
		NumberFormat::I128 => format!("crate::generated::shared::PodI128::from({literal})"),
		NumberFormat::F32 | NumberFormat::F64 | NumberFormat::ShortU16 => unreachable!(),
	})
}

fn render_type_for_pod(r#type: &TypeNode, context: &str) -> Result<String> {
	match r#type {
		TypeNode::Number(number_type) => render_number_type_for_pod(number_type, context),
		TypeNode::Boolean(boolean_type) => render_boolean_type(boolean_type, context),
		TypeNode::PublicKey(_) => Ok("solana_pubkey::Pubkey".to_string()),
		TypeNode::Bytes(_) => {
			Err(RenderError::UnsupportedType {
				context: context.to_string(),
				kind: r#type.kind(),
				reason: "bytes must be wrapped in fixedSizeTypeNode".to_string(),
			})
		}
		TypeNode::String(_) => {
			Err(RenderError::UnsupportedType {
				context: context.to_string(),
				kind: r#type.kind(),
				reason: "variable-size strings are not POD".to_string(),
			})
		}
		TypeNode::FixedSize(fixed_size) => {
			if matches!(fixed_size.r#type.as_ref(), TypeNode::Bytes(_)) {
				Ok(format!("[u8; {}]", fixed_size.size))
			} else {
				let inner = render_type_for_pod(&fixed_size.r#type, context)?;
				Ok(format!("[{inner}; {}]", fixed_size.size))
			}
		}
		TypeNode::Array(array_type) => {
			let item_type = render_type_for_pod(&array_type.item, context)?;
			match &array_type.count {
				CountNode::Fixed(count) => Ok(format!("[{item_type}; {}]", count.value)),
				CountNode::Prefixed(_) | CountNode::Remainder(_) => {
					Err(RenderError::UnsupportedType {
						context: context.to_string(),
						kind: r#type.kind(),
						reason: "only fixed-size arrays are POD".to_string(),
					})
				}
			}
		}
		TypeNode::Link(link) => {
			Ok(format!(
				"crate::generated::types::{}",
				pascal(link.name.as_ref())
			))
		}
		unsupported => {
			Err(RenderError::UnsupportedType {
				context: context.to_string(),
				kind: unsupported.kind(),
				reason: "node kind is not supported by pina_codama_renderer yet".to_string(),
			})
		}
	}
}

fn render_number_type_for_pod(number_type: &NumberTypeNode, context: &str) -> Result<String> {
	if !matches!(number_type.endian, Endian::Little) {
		return Err(RenderError::UnsupportedType {
			context: context.to_string(),
			kind: "numberTypeNode",
			reason: "only little-endian number types are supported".to_string(),
		});
	}

	match number_type.format {
		NumberFormat::U8 => Ok("u8".to_string()),
		NumberFormat::I8 => Ok("i8".to_string()),
		NumberFormat::U16 => Ok("crate::generated::shared::PodU16".to_string()),
		NumberFormat::I16 => Ok("crate::generated::shared::PodI16".to_string()),
		NumberFormat::U32 => Ok("crate::generated::shared::PodU32".to_string()),
		NumberFormat::I32 => Ok("crate::generated::shared::PodI32".to_string()),
		NumberFormat::U64 => Ok("crate::generated::shared::PodU64".to_string()),
		NumberFormat::I64 => Ok("crate::generated::shared::PodI64".to_string()),
		NumberFormat::U128 => Ok("crate::generated::shared::PodU128".to_string()),
		NumberFormat::I128 => Ok("crate::generated::shared::PodI128".to_string()),
		NumberFormat::F32 | NumberFormat::F64 | NumberFormat::ShortU16 => {
			Err(RenderError::UnsupportedType {
				context: context.to_string(),
				kind: "numberTypeNode",
				reason: format!("format `{:?}` is not POD-compatible", number_type.format),
			})
		}
	}
}

fn render_boolean_type(
	boolean_type: &codama_nodes::BooleanTypeNode,
	context: &str,
) -> Result<String> {
	let number_type = boolean_type.size.get_nested_type_node();
	if !matches!(number_type.format, NumberFormat::U8)
		|| !matches!(number_type.endian, Endian::Little)
	{
		return Err(RenderError::UnsupportedType {
			context: context.to_string(),
			kind: "booleanTypeNode",
			reason: "booleans must be encoded as little-endian u8".to_string(),
		});
	}
	Ok("crate::generated::shared::PodBool".to_string())
}

fn render_variable_seed_parameter(
	seed_name: &str,
	r#type: &TypeNode,
	context: &str,
) -> Result<(String, String)> {
	match r#type {
		TypeNode::PublicKey(_) => {
			Ok((
				"&solana_pubkey::Pubkey".to_string(),
				format!("{seed_name}.as_ref()"),
			))
		}
		TypeNode::Boolean(boolean_type) => {
			let number_type = boolean_type.size.get_nested_type_node();
			if !matches!(number_type.format, NumberFormat::U8)
				|| !matches!(number_type.endian, Endian::Little)
			{
				return Err(RenderError::UnsupportedType {
					context: context.to_string(),
					kind: "booleanTypeNode",
					reason: "booleans must use little-endian u8 for PDA seeds".to_string(),
				});
			}
			Ok(("bool".to_string(), format!("&[u8::from({seed_name})]")))
		}
		TypeNode::Number(number_type) => {
			if !matches!(number_type.endian, Endian::Little) {
				return Err(RenderError::UnsupportedType {
					context: context.to_string(),
					kind: "numberTypeNode",
					reason: "only little-endian numbers are supported for PDA seeds".to_string(),
				});
			}
			let number_ty = match number_type.format {
				NumberFormat::U8 => "u8",
				NumberFormat::I8 => "i8",
				NumberFormat::U16 => "u16",
				NumberFormat::I16 => "i16",
				NumberFormat::U32 => "u32",
				NumberFormat::I32 => "i32",
				NumberFormat::U64 => "u64",
				NumberFormat::I64 => "i64",
				NumberFormat::U128 => "u128",
				NumberFormat::I128 => "i128",
				NumberFormat::F32 | NumberFormat::F64 | NumberFormat::ShortU16 => {
					return Err(RenderError::UnsupportedType {
						context: context.to_string(),
						kind: "numberTypeNode",
						reason: "float/shortU16 seed numbers are unsupported".to_string(),
					});
				}
			};
			let bytes_expr = if matches!(number_type.format, NumberFormat::U8 | NumberFormat::I8) {
				format!("&{seed_name}.to_le_bytes()")
			} else {
				format!("&{seed_name}.to_le_bytes()")
			};
			Ok((number_ty.to_string(), bytes_expr))
		}
		TypeNode::FixedSize(fixed_size) => {
			if matches!(fixed_size.r#type.as_ref(), TypeNode::Bytes(_)) {
				Ok((
					format!("&[u8; {}]", fixed_size.size),
					format!("&{seed_name}[..]"),
				))
			} else {
				let inner = render_type_for_pod(&fixed_size.r#type, context)?;
				Ok((
					format!("&[{inner}; {}]", fixed_size.size),
					format!("&{seed_name}[..]"),
				))
			}
		}
		TypeNode::Array(array) => {
			match &array.count {
				CountNode::Fixed(count) => {
					let inner = render_type_for_pod(&array.item, context)?;
					Ok((
						format!("&[{inner}; {}]", count.value),
						format!("&{seed_name}[..]"),
					))
				}
				CountNode::Prefixed(_) | CountNode::Remainder(_) => {
					Err(RenderError::UnsupportedType {
						context: context.to_string(),
						kind: "arrayTypeNode",
						reason: "only fixed arrays are supported for PDA seeds".to_string(),
					})
				}
			}
		}
		other => {
			Err(RenderError::UnsupportedType {
				context: context.to_string(),
				kind: other.kind(),
				reason: "unsupported variable PDA seed type".to_string(),
			})
		}
	}
}

fn render_constant_seed_expression(
	r#type: &TypeNode,
	value: &ValueNode,
	context: &str,
	primary_program_const: &str,
) -> Result<String> {
	match value {
		ValueNode::String(string_value) => Ok(format!("{:?}.as_bytes()", string_value.string)),
		ValueNode::Number(number_value) => {
			render_number_seed_expression(r#type, &number_value.number, context)
		}
		ValueNode::PublicKey(public_key_value) => {
			Ok(format!(
				"solana_pubkey::pubkey!(\"{}\").as_ref()",
				public_key_value.public_key
			))
		}
		ValueNode::Constant(constant_value) => {
			match constant_value.value.as_ref() {
				ValueNode::String(string_value) => {
					Ok(format!("{:?}.as_bytes()", string_value.string))
				}
				ValueNode::Number(number_value) => {
					render_number_seed_expression(
						constant_value.r#type.as_ref(),
						&number_value.number,
						context,
					)
				}
				other => {
					Err(RenderError::UnsupportedValue {
						context: context.to_string(),
						kind: other.kind(),
						reason: "unsupported nested constant seed value".to_string(),
					})
				}
			}
		}
		ValueNode::Bytes(bytes_value) => {
			if matches!(bytes_value.encoding, codama_nodes::BytesEncoding::Utf8) {
				Ok(format!("{:?}.as_bytes()", bytes_value.data))
			} else {
				Err(RenderError::UnsupportedValue {
					context: context.to_string(),
					kind: value.kind(),
					reason: "non-utf8 bytes seeds are unsupported".to_string(),
				})
			}
		}
		other => {
			Err(RenderError::UnsupportedValue {
				context: context.to_string(),
				kind: other.kind(),
				reason: format!(
					"supported constant seed values are string/number/publicKey (program const: \
					 {primary_program_const})"
				),
			})
		}
	}
}

fn render_number_seed_expression(
	r#type: &TypeNode,
	value: &Number,
	context: &str,
) -> Result<String> {
	let TypeNode::Number(number_type) = r#type else {
		return Err(RenderError::UnsupportedType {
			context: context.to_string(),
			kind: r#type.kind(),
			reason: "numeric seed value requires number type".to_string(),
		});
	};
	if !matches!(number_type.endian, Endian::Little) {
		return Err(RenderError::UnsupportedType {
			context: context.to_string(),
			kind: "numberTypeNode",
			reason: "only little-endian numeric seeds are supported".to_string(),
		});
	}
	let literal = match number_type.format {
		NumberFormat::U8 => format!("{}u8", cast_unsigned(value, u8::MAX as u128, context)?),
		NumberFormat::I8 => {
			format!(
				"{}i8",
				cast_signed(value, i8::MIN as i128, i8::MAX as i128, context)?
			)
		}
		NumberFormat::U16 => format!("{}u16", cast_unsigned(value, u16::MAX as u128, context)?),
		NumberFormat::I16 => {
			format!(
				"{}i16",
				cast_signed(value, i16::MIN as i128, i16::MAX as i128, context)?
			)
		}
		NumberFormat::U32 => format!("{}u32", cast_unsigned(value, u32::MAX as u128, context)?),
		NumberFormat::I32 => {
			format!(
				"{}i32",
				cast_signed(value, i32::MIN as i128, i32::MAX as i128, context)?
			)
		}
		NumberFormat::U64 => format!("{}u64", cast_unsigned(value, u64::MAX as u128, context)?),
		NumberFormat::I64 => {
			format!(
				"{}i64",
				cast_signed(value, i64::MIN as i128, i64::MAX as i128, context)?
			)
		}
		NumberFormat::U128 => format!("{}u128", cast_unsigned(value, u128::MAX, context)?),
		NumberFormat::I128 => format!("{}i128", cast_signed(value, i128::MIN, i128::MAX, context)?),
		NumberFormat::F32 | NumberFormat::F64 | NumberFormat::ShortU16 => {
			return Err(RenderError::UnsupportedType {
				context: context.to_string(),
				kind: "numberTypeNode",
				reason: "float/shortU16 numeric seeds are unsupported".to_string(),
			});
		}
	};
	Ok(match number_type.format {
		NumberFormat::U8 | NumberFormat::I8 => format!("&{literal}.to_le_bytes()"),
		_ => format!("&{literal}.to_le_bytes()"),
	})
}

fn cast_unsigned(value: &Number, max: u128, context: &str) -> Result<u128> {
	let parsed = match value {
		Number::UnsignedInteger(value) => u128::from(*value),
		Number::SignedInteger(value) => {
			u128::try_from(*value).map_err(|_| {
				RenderError::UnsupportedValue {
					context: context.to_string(),
					kind: "numberValueNode",
					reason: "negative number cannot be cast to unsigned value".to_string(),
				}
			})?
		}
		Number::Float(_) => {
			return Err(RenderError::UnsupportedValue {
				context: context.to_string(),
				kind: "numberValueNode",
				reason: "float cannot be cast to integer".to_string(),
			});
		}
	};
	if parsed > max {
		return Err(RenderError::UnsupportedValue {
			context: context.to_string(),
			kind: "numberValueNode",
			reason: format!("value `{parsed}` exceeds max `{max}`"),
		});
	}
	Ok(parsed)
}

fn cast_signed(value: &Number, min: i128, max: i128, context: &str) -> Result<i128> {
	let parsed = match value {
		Number::UnsignedInteger(value) => {
			i128::try_from(*value).map_err(|_| {
				RenderError::UnsupportedValue {
					context: context.to_string(),
					kind: "numberValueNode",
					reason: "unsigned value cannot fit into signed integer".to_string(),
				}
			})?
		}
		Number::SignedInteger(value) => i128::from(*value),
		Number::Float(_) => {
			return Err(RenderError::UnsupportedValue {
				context: context.to_string(),
				kind: "numberValueNode",
				reason: "float cannot be cast to integer".to_string(),
			});
		}
	};
	if parsed < min || parsed > max {
		return Err(RenderError::UnsupportedValue {
			context: context.to_string(),
			kind: "numberValueNode",
			reason: format!("value `{parsed}` is out of range [{min}, {max}]"),
		});
	}
	Ok(parsed)
}

fn render_docs(docs: &Docs, indent_level: usize) -> Vec<String> {
	let indent = "\t".repeat(indent_level);
	docs.iter()
		.map(|line| format!("{indent}/// {line}"))
		.collect()
}

fn page(body: &str) -> String {
	format!("{GENERATED_HEADER}\n{body}\n")
}

fn pascal(value: &str) -> String {
	value.to_upper_camel_case()
}

fn snake(value: &str) -> String {
	value.to_snake_case()
}

fn shouty(value: &str) -> String {
	value.to_shouty_snake_case()
}

fn program_id_const_name(program_name: &str) -> String {
	shouty(program_name) + "_ID"
}

fn escape_rust_str(value: &str) -> String {
	value.replace('\\', "\\\\").replace('"', "\\\"")
}

#[cfg(test)]
mod tests {
	use std::path::Path;
	use std::path::PathBuf;
	use std::time::SystemTime;
	use std::time::UNIX_EPOCH;

	use codama_nodes::AccountNode;
	use codama_nodes::BooleanTypeNode;
	use codama_nodes::ConstantDiscriminatorNode;
	use codama_nodes::ConstantValueNode;
	use codama_nodes::DefinedTypeNode;
	use codama_nodes::DiscriminatorNode;
	use codama_nodes::Endian;
	use codama_nodes::InstructionAccountNode;
	use codama_nodes::InstructionNode;
	use codama_nodes::NumberTypeNode;
	use codama_nodes::NumberValueNode;
	use codama_nodes::PdaLinkNode;
	use codama_nodes::PdaNode;
	use codama_nodes::PdaSeedNode;
	use codama_nodes::ProgramNode;
	use codama_nodes::RootNode;
	use codama_nodes::StringTypeNode;
	use codama_nodes::StructFieldTypeNode;
	use codama_nodes::StructTypeNode;
	use codama_nodes::TypeNode;
	use codama_nodes::U8;

	use super::*;

	fn unique_temp_dir(prefix: &str) -> PathBuf {
		let nanos = SystemTime::now()
			.duration_since(UNIX_EPOCH)
			.unwrap_or_default()
			.as_nanos();
		std::env::temp_dir().join(format!("{prefix}-{nanos}"))
	}

	fn repo_root() -> PathBuf {
		Path::new(env!("CARGO_MANIFEST_DIR"))
			.parent()
			.and_then(Path::parent)
			.unwrap_or_else(|| Path::new("."))
			.to_path_buf()
	}

	fn load_fixture_root(name: &str) -> RootNode {
		let fixture_path = repo_root().join("codama/idls").join(format!("{name}.json"));
		read_root_node(&fixture_path)
			.unwrap_or_else(|e| panic!("failed to load fixture {}: {e}", fixture_path.display()))
	}

	fn render_fixture_program(name: &str, prefix: &str) -> PathBuf {
		let root = load_fixture_root(name);
		let output_dir = unique_temp_dir(prefix);
		let crate_dir = output_dir.join(name);
		render_root_node(&root, &crate_dir, &RenderConfig::default())
			.unwrap_or_else(|e| panic!("render failed for `{name}`: {e}"));
		crate_dir
	}

	fn read_generated_file(crate_dir: &Path, path: &str) -> String {
		let generated_path = crate_dir.join("src/generated").join(path);
		fs::read_to_string(&generated_path).unwrap_or_else(|e| {
			panic!(
				"failed to read generated file {}: {e}",
				generated_path.display()
			)
		})
	}

	#[test]
	fn renders_counter_account_with_pod_types() {
		let crate_dir = render_fixture_program("counter_program", "pina-codama-render-counter");
		let content = read_generated_file(&crate_dir, "accounts/counter_state.rs");

		assert!(content.contains("use bytemuck::Pod;"));
		assert!(content.contains("pub discriminator: u8,"));
		assert!(content.contains("pub count: crate::generated::shared::PodU64,"));
		assert!(content.contains("pub const COUNTER_STATE_DISCRIMINATOR: u8 = 1u8;"));
		assert!(content.contains("crate::generated::shared::pod_from_bytes::<Self>(data)?;"));
		insta::assert_snapshot!("counter_state_account_rs", content);
	}

	#[test]
	fn renders_instruction_data_with_discriminator_prefix() {
		let crate_dir = render_fixture_program("todo_program", "pina-codama-render-todo");
		let content = read_generated_file(&crate_dir, "instructions/initialize.rs");

		assert!(content.contains("pub const INITIALIZE_DISCRIMINATOR: u8 = 0u8;"));
		assert!(content.contains("pub struct InitializeInstructionData {"));
		assert!(content.contains("pub discriminator: u8,"));
		assert!(content.contains("pub digest: [u8; 32],"));
		assert!(content.contains("let data = bytemuck::bytes_of(&data).to_vec();"));
		insta::assert_snapshot!("todo_initialize_instruction_rs", content);
	}

	#[test]
	fn renders_instruction_account_metas_using_self_fields() {
		let crate_dir =
			render_fixture_program("counter_program", "pina-codama-render-self-account-metas");
		let initialize_content = read_generated_file(&crate_dir, "instructions/initialize.rs");
		let increment_content = read_generated_file(&crate_dir, "instructions/increment.rs");

		assert!(initialize_content.contains("AccountMeta::new_readonly(self.authority, true)"));
		assert!(initialize_content.contains("AccountMeta::new(self.counter, false)"));
		assert!(
			initialize_content.contains("AccountMeta::new_readonly(self.system_program, false)")
		);

		assert!(increment_content.contains("AccountMeta::new_readonly(self.authority, true)"));
		assert!(increment_content.contains("AccountMeta::new(self.counter, false)"));
	}

	#[test]
	fn renders_pda_helpers_for_linked_account() {
		let program = ProgramNode {
			name: "exampleProgram".into(),
			public_key: "11111111111111111111111111111111".to_string(),
			accounts: vec![AccountNode {
				name: "state".into(),
				size: None,
				docs: Docs::default(),
				data: StructTypeNode::new(vec![]).into(),
				pda: Some(PdaLinkNode::new("statePda")),
				discriminators: vec![DiscriminatorNode::Constant(ConstantDiscriminatorNode::new(
					ConstantValueNode::new(NumberTypeNode::le(U8), NumberValueNode::new(1u8)),
					0,
				))],
			}],
			instructions: vec![],
			defined_types: vec![],
			pdas: vec![PdaNode::new(
				"statePda",
				vec![PdaSeedNode::Constant(
					codama_nodes::ConstantPdaSeedNode::new(
						StringTypeNode::utf8(),
						codama_nodes::StringValueNode::new("state"),
					),
				)],
			)],
			errors: vec![],
			version: String::new(),
			origin: None,
			docs: Docs::default(),
		};
		let root = RootNode::new(program);

		let output_dir = unique_temp_dir("pina-codama-render-pda");
		let crate_dir = output_dir.join("example_program");
		render_root_node(&root, &crate_dir, &RenderConfig::default())
			.unwrap_or_else(|e| panic!("render failed: {e}"));

		let content = read_generated_file(&crate_dir, "accounts/state.rs");

		assert!(content.contains("pub fn find_pda("));
		assert!(content.contains("pub fn create_pda("));
	}

	#[test]
	fn renders_optional_accounts_with_program_fallback_strategy() {
		let mut optional_signer = InstructionAccountNode::new("optionalSigner", false, false);
		optional_signer.is_optional = true;
		optional_signer.is_signer = IsAccountSigner::Either;

		let program = ProgramNode {
			name: "optionalProgram".into(),
			public_key: "11111111111111111111111111111111".to_string(),
			accounts: vec![],
			instructions: vec![InstructionNode {
				name: "maybe".into(),
				docs: Docs::default(),
				optional_account_strategy: InstructionOptionalAccountStrategy::ProgramId,
				accounts: vec![optional_signer],
				arguments: vec![],
				extra_arguments: vec![],
				remaining_accounts: vec![],
				byte_deltas: vec![],
				discriminators: vec![DiscriminatorNode::Constant(ConstantDiscriminatorNode::new(
					ConstantValueNode::new(NumberTypeNode::le(U8), NumberValueNode::new(9u8)),
					0,
				))],
				status: None,
				sub_instructions: vec![],
			}],
			defined_types: vec![],
			pdas: vec![],
			errors: vec![],
			version: String::new(),
			origin: None,
			docs: Docs::default(),
		};
		let output_dir = unique_temp_dir("pina-codama-render-optional-fallback");
		let crate_dir = output_dir.join("optional_program");
		render_root_node(
			&RootNode::new(program),
			&crate_dir,
			&RenderConfig::default(),
		)
		.unwrap_or_else(|e| panic!("render failed: {e}"));

		let content = read_generated_file(&crate_dir, "instructions/maybe.rs");
		assert!(
			content.contains("if let Some((optional_signer, signer)) = self.optional_signer {")
		);
		assert!(content.contains("crate::OPTIONAL_PROGRAM_ID"));
	}

	#[test]
	fn rejects_variable_size_strings() {
		let program = ProgramNode {
			name: "badProgram".into(),
			public_key: "11111111111111111111111111111111".to_string(),
			accounts: vec![AccountNode {
				name: "state".into(),
				size: None,
				docs: Docs::default(),
				data: StructTypeNode::new(vec![StructFieldTypeNode::new(
					"memo",
					StringTypeNode::utf8(),
				)])
				.into(),
				pda: None,
				discriminators: vec![DiscriminatorNode::Constant(ConstantDiscriminatorNode::new(
					ConstantValueNode::new(NumberTypeNode::le(U8), NumberValueNode::new(1u8)),
					0,
				))],
			}],
			instructions: vec![],
			defined_types: vec![],
			pdas: vec![],
			errors: vec![],
			version: String::new(),
			origin: None,
			docs: Docs::default(),
		};

		let result = render_root_node(
			&RootNode::new(program),
			&unique_temp_dir("pina-codama-render-bad"),
			&RenderConfig::default(),
		);

		let err = match result {
			Ok(()) => panic!("expected string type render to fail"),
			Err(err) => err,
		};
		assert!(
			err.to_string()
				.contains("variable-size strings are not POD"),
			"unexpected error: {err}"
		);
	}

	#[test]
	fn rejects_big_endian_numbers() {
		let program = ProgramNode {
			name: "bigEndianProgram".into(),
			public_key: "11111111111111111111111111111111".to_string(),
			accounts: vec![AccountNode {
				name: "state".into(),
				size: None,
				docs: Docs::default(),
				data: StructTypeNode::new(vec![StructFieldTypeNode::new(
					"count",
					NumberTypeNode {
						format: NumberFormat::U16,
						endian: Endian::Big,
					},
				)])
				.into(),
				pda: None,
				discriminators: vec![DiscriminatorNode::Constant(ConstantDiscriminatorNode::new(
					ConstantValueNode::new(NumberTypeNode::le(U8), NumberValueNode::new(1u8)),
					0,
				))],
			}],
			instructions: vec![],
			defined_types: vec![],
			pdas: vec![],
			errors: vec![],
			version: String::new(),
			origin: None,
			docs: Docs::default(),
		};

		let err = render_root_node(
			&RootNode::new(program),
			&unique_temp_dir("pina-codama-render-big-endian"),
			&RenderConfig::default(),
		)
		.err()
		.unwrap_or_else(|| panic!("expected big-endian render to fail"));

		assert!(
			err.to_string()
				.contains("only little-endian number types are supported"),
			"unexpected error: {err}"
		);
	}

	#[test]
	fn renders_defined_type_aliases_with_pod_wrappers() {
		let program = ProgramNode {
			name: "aliasProgram".into(),
			public_key: "11111111111111111111111111111111".to_string(),
			accounts: vec![],
			instructions: vec![],
			defined_types: vec![DefinedTypeNode {
				name: "counter".into(),
				docs: Docs::default(),
				r#type: TypeNode::Number(NumberTypeNode {
					format: NumberFormat::U64,
					endian: Endian::Little,
				}),
			}],
			pdas: vec![],
			errors: vec![],
			version: String::new(),
			origin: None,
			docs: Docs::default(),
		};
		let root = RootNode::new(program);

		let output_dir = unique_temp_dir("pina-codama-render-alias");
		let crate_dir = output_dir.join("alias_program");
		render_root_node(&root, &crate_dir, &RenderConfig::default())
			.unwrap_or_else(|e| panic!("render failed: {e}"));

		let content = read_generated_file(&crate_dir, "types/counter.rs");
		assert!(content.contains("pub type Counter = crate::generated::shared::PodU64;"));
		insta::assert_snapshot!("defined_type_alias_counter_rs", content);
	}

	#[test]
	fn rejects_missing_instruction_discriminators() {
		let program = ProgramNode {
			name: "missingIxDisc".into(),
			public_key: "11111111111111111111111111111111".to_string(),
			accounts: vec![],
			instructions: vec![InstructionNode {
				name: "doThing".into(),
				docs: Docs::default(),
				optional_account_strategy: InstructionOptionalAccountStrategy::ProgramId,
				accounts: vec![InstructionAccountNode::new("payer", true, true)],
				arguments: vec![],
				extra_arguments: vec![],
				remaining_accounts: vec![],
				byte_deltas: vec![],
				discriminators: vec![],
				status: None,
				sub_instructions: vec![],
			}],
			defined_types: vec![],
			pdas: vec![],
			errors: vec![],
			version: String::new(),
			origin: None,
			docs: Docs::default(),
		};
		let root = RootNode::new(program);

		let err = render_root_node(
			&root,
			&unique_temp_dir("pina-codama-render-missing-discriminator"),
			&RenderConfig::default(),
		)
		.err()
		.unwrap_or_else(|| panic!("expected render to fail"));

		assert!(
			err.to_string().contains("missing required discriminator"),
			"unexpected error: {err}"
		);
	}

	#[test]
	fn writes_scaffold_with_bytemuck_dependency() {
		let root = load_fixture_root("hello_solana");
		let output_dir = unique_temp_dir("pina-codama-render-scaffold");
		let crate_dir = output_dir.join("hello_solana");

		render_root_node(&root, &crate_dir, &RenderConfig::default())
			.unwrap_or_else(|e| panic!("render failed: {e}"));

		let cargo_toml_path = crate_dir.join("Cargo.toml");
		let cargo_toml = fs::read_to_string(&cargo_toml_path).unwrap_or_else(|e| {
			panic!(
				"failed to read generated cargo manifest {}: {e}",
				cargo_toml_path.display()
			)
		});
		assert!(cargo_toml.contains("bytemuck = { workspace = true }"));
		assert!(!cargo_toml.contains("borsh = { workspace = true }"));
	}

	#[test]
	fn validates_boolean_encoding_for_pda_variable_seed() {
		let boolean_type = BooleanTypeNode {
			size: NumberTypeNode {
				format: NumberFormat::U16,
				endian: Endian::Little,
			}
			.into(),
		};
		let err = render_variable_seed_parameter(
			"seed",
			&TypeNode::Boolean(boolean_type),
			"pda boolean seed test",
		)
		.err()
		.unwrap_or_else(|| panic!("expected invalid boolean encoding error"));

		assert!(
			err.to_string()
				.contains("booleans must use little-endian u8 for PDA seeds"),
			"unexpected error: {err}"
		);
	}

	#[test]
	fn snapshots_escrow_take_instruction() {
		let crate_dir = render_fixture_program("escrow_program", "pina-codama-render-escrow");
		let content = read_generated_file(&crate_dir, "instructions/take.rs");
		insta::assert_snapshot!("escrow_take_instruction_rs", content);
	}
}
